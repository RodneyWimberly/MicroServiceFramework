/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.4.2.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { Subject, from, throwError } from 'rxjs';
import { map, mergeMap, switchMap, catchError } from 'rxjs/operators';
import { Router, NavigationExtras } from '@angular/router';
import { AuthConfig, JwksValidationHandler, LoginOptions, OAuthService } from 'angular-oauth2-oidc';
import { LocalStorageService } from './local-storage.service';
import { ConfigurationService } from './configuration.service';
import { DbKeys } from '../helpers/db-keys';
import { JwtHelper } from '../helpers/jwt-helper';
import { Utilities } from '../helpers/utilities';
import { AccessTokenModel } from '../models/access-token.model';
import { AuthStorageService } from './auth-storage.service';
import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, from as _observableFrom, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { AuthProviders } from '../models/user-login.model';
import { error, exception } from 'console';
import { AlertCommand, AlertMessage, AlertService, MessageSeverity } from './alert.service';
import { AuthProvidersModel } from '../models/enum.models';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AuthEndpointService {
  public get webBaseUrl(): string { return this.configService.webBaseUrl; }
  public get loginUrl(): string { return this.configService.loginUrl; }
  public get homeUrl(): string { return this.configService.homeUrl; }
  public get apiBaseUrl(): string { return this.configService.apiBaseUrl + '/v' + this.apiVersion; }
  public get apiVersion(): string { return this.configService.apiVersion; }
  public get authConfig(): AuthConfig { return this.configService.authConfig; }
  public get authProvider(): AuthProvidersModel { return this.configService.authProvider; }
  public set authProvider(value: AuthProvidersModel) { this.configService.authProvider = value; }
  public loginRedirectUrl: string;
  public logoutRedirectUrl: string;
  public reLoginDelegate: () => void;

  private _previousIsLoggedInCheck = false;
  private _loginStatus = new Subject<boolean>();

  constructor(
    @Inject(Router) private router: Router,
    @Inject(OAuthService) public oAuthService: OAuthService,
    @Inject(ConfigurationService) private configService: ConfigurationService,
    @Inject(LocalStorageService) private storageService: LocalStorageService,
    @Inject(AlertService) private alertService: AlertService) {

    this.initializeLoginStatus();
  }

  private initializeLoginStatus() {
    this.storageService.getInitEvent().subscribe(() => {
      this.reevaluateLoginStatus();
    });
  }

  gotoPage(page: string, preserveParams = true) {
    const navigationExtras: NavigationExtras = {
      queryParamsHandling: preserveParams ? 'merge' : '', preserveFragment: preserveParams
    };

    this.router.navigate([page], navigationExtras);
  }

  gotoHomePage() {
    this.router.navigate([this.homeUrl]);
  }

  redirectLoginUser() {
    const redirect = this.loginRedirectUrl && this.loginRedirectUrl != '/' && this.loginRedirectUrl != ConfigurationService.defaultHomeUrl ? this.loginRedirectUrl : this.homeUrl;
    this.loginRedirectUrl = null;

    const urlParamsAndFragment = Utilities.splitInTwo(redirect, '#');
    const urlAndParams = Utilities.splitInTwo(urlParamsAndFragment.firstPart, '?');

    const navigationExtras: NavigationExtras = {
      fragment: urlParamsAndFragment.secondPart,
      queryParams: Utilities.getQueryParamsFromString(urlAndParams.secondPart),
      queryParamsHandling: 'merge'
    };

    this.router.navigate([urlAndParams.firstPart], navigationExtras);
  }

  redirectLogoutUser() {
    const redirect = this.logoutRedirectUrl ? this.logoutRedirectUrl : this.loginUrl;
    this.logoutRedirectUrl = null;
    this.router.navigate([redirect]);
  }

  redirectForLogin() {
    this.loginRedirectUrl = this.router.url;
    this.router.navigate([this.loginUrl]);
  }

  reLogin() {
    if (this.reLoginDelegate)
      this.reLoginDelegate();
    else
      this.redirectForLogin();
  }

  refreshLogin(): Observable<UserViewModel> {
    if (this.oAuthService.discoveryDocumentLoaded) {
      return from(this.refreshLoginAuthProvider()).pipe(
        map(() => this.processLoginResponse(this.oAuthService.getAccessToken(), this.rememberMe)));
    } else {
      this.configureAuthService();
      return from(this.oAuthService.loadDiscoveryDocument())
        .pipe(mergeMap(() => this.refreshLogin()));
    }
  }

  private refreshLoginAuthProvider() {
    if (this.authProvider == 'idsvr')
      return this.oAuthService.refreshToken()
    else
      return this.oAuthService.silentRefresh();
  }

  async login(authProvider: AuthProvidersModel, userName?: string, password?: string, rememberMe?: boolean) {
    if (this.isLoggedIn) this.logout();
    this.alertService.startLoadingMessage("Attempting login...");

    this.authProvider = authProvider;
    this.configureAuthService();
    AuthStorageService.RememberMe = rememberMe;
    await this.oAuthService.loadDiscoveryDocument();
    if (this.authProvider == 'idsvr') {
      await this.oAuthService.fetchTokenUsingPasswordFlow(userName, password);
      this.processLoginResponse(this.oAuthService.getAccessToken(), rememberMe);
    }
    else
      await this.oAuthService.initImplicitFlow();
  }

  public configureAuthService() {
    this.oAuthService.configure(this.authConfig);
    this.oAuthService.tokenValidationHandler = new JwksValidationHandler();
  }

  async processImplicitFlowResponse() {
    try {
      this.configureAuthService();
      if (await this.oAuthService.loadDiscoveryDocumentAndLogin({ disableOAuth2StateCheck: true, preventClearHashAfterLogin: false })
        && this.oAuthService.hasValidAccessToken) {
        this.oAuthService.setupAutomaticSilentRefresh();
        return this.processLoginResponse(this.oAuthService.getIdToken(), true);
      }
      else {
        this.alertService.showStickyMessage("Login", "Error logging into Auth Provider", MessageSeverity.error);
        this.gotoPage("login");
        return null;
      }
    }
    catch (error) {
      const errorsRequiringUserInteraction = [
        'interaction_required',
        'login_required',
        'account_selection_required',
        'consent_required',
      ];
      if (error && error.reason && errorsRequiringUserInteraction.indexOf(error.reason.error) >= 0)
        this.oAuthService.initImplicitFlow();
      else
        throwError(error);
    }
  }

  processLoginResponse(accessToken: string, rememberMe: boolean) {
    if (accessToken == null)
      throw new Error('accessToken cannot be null');

    const jwtHelper = new JwtHelper();
    const decodedAccessToken = jwtHelper.decodeToken(accessToken) as AccessTokenModel;
    const permissions: PermissionValues[] = Array.isArray(decodedAccessToken.permission) ? decodedAccessToken.permission : [decodedAccessToken.permission];

    if (!this.isLoggedIn)
      this.configService.import(decodedAccessToken.configuration);

    const user = new UserViewModel();
    user.id = decodedAccessToken.sub;
    user.userName = decodedAccessToken.name;
    user.fullName = decodedAccessToken.fullname;
    user.email = decodedAccessToken.email;
    user.jobTitle = decodedAccessToken.jobtitle;
    user.phoneNumber = decodedAccessToken.phone_number;
    user.roles = Array.isArray(decodedAccessToken.role) ? decodedAccessToken.role : [decodedAccessToken.role];
    user.isEnabled = true;

    this.saveUserDetails(user, permissions, rememberMe);
    this.reevaluateLoginStatus(user);
    this.alertService.stopLoadingMessage();
    this.gotoHomePage();

    return user;
  }

  private saveUserDetails(user: UserViewModel, permissions: PermissionValues[], rememberMe: boolean) {
    if (rememberMe) {
      this.storageService.savePermanentData(permissions, DbKeys.USER_PERMISSIONS);
      this.storageService.savePermanentData(user, DbKeys.CURRENT_USER);
    } else {
      this.storageService.saveSyncedSessionData(permissions, DbKeys.USER_PERMISSIONS);
      this.storageService.saveSyncedSessionData(user, DbKeys.CURRENT_USER);
    }

    this.storageService.savePermanentData(rememberMe, DbKeys.REMEMBER_ME);
  }

  logout(): void {
    this.storageService.deleteData(DbKeys.USER_PERMISSIONS);
    this.storageService.deleteData(DbKeys.CURRENT_USER);

    this.configService.clearLocalChanges();
    this.oAuthService.logOut(true);

    this.reevaluateLoginStatus();
  }

  private reevaluateLoginStatus(currentUser?: UserViewModel) {
    const user = currentUser || this.storageService.getDataObject<UserViewModel>(DbKeys.CURRENT_USER);
    const isLoggedIn = user != null && this.oAuthService.hasValidAccessToken();

    if (this._previousIsLoggedInCheck != isLoggedIn) {
      setTimeout(() => {
        this._loginStatus.next(isLoggedIn);
      });
    }

    this._previousIsLoggedInCheck = isLoggedIn;
  }

  getLoginStatusEvent(): Observable<boolean> {
    return this._loginStatus.asObservable();
  }

  get currentUser(): UserViewModel {

    const user = this.storageService.getDataObject<UserViewModel>(DbKeys.CURRENT_USER);
    this.reevaluateLoginStatus(user);

    return user;
  }

  get userPermissions(): PermissionValue[] {
    return this.storageService.getDataObject<PermissionValue[]>(DbKeys.USER_PERMISSIONS) || [];
  }

  get accessToken(): string {
    return this.authProvider == 'idsvr' ?
      this.oAuthService.getAccessToken() :
      this.oAuthService.getIdToken();
  }

  get accessTokenExpiryDate(): Date {
    return new Date(this.oAuthService.getAccessTokenExpiration());
  }

  get isSessionExpired(): boolean {
    if (this.accessTokenExpiryDate == null) {
      return true;
    }

    return this.accessTokenExpiryDate.valueOf() <= new Date().valueOf();
  }

  get refreshToken(): string {
    return this.oAuthService.getRefreshToken();
  }

  get isLoggedIn(): boolean {
    return this.currentUser != null && this.oAuthService.hasValidAccessToken();
  }

  get rememberMe(): boolean {
    return this.storageService.getDataObject<boolean>(DbKeys.REMEMBER_ME) == true;
  }
}

export class BaseEndpointService {

  private taskPauser: Subject<any>;
  private isRefreshingLogin: boolean;
  protected get apiBaseUrl(): string { return this.configService.apiBaseUrl + '/v' + this.apiVersion; }
  protected get apiVersion(): string { return this.configService.apiVersion; }

  constructor(protected configService: ConfigurationService,
    protected authService: AuthEndpointService) {
  }

  protected transformOptions(options: any): Promise<any> {
    options.headers = new HttpHeaders({
      Authorization: 'Bearer ' + this.authService.accessToken,
      'Content-Type': 'application/json',
      Accept: 'application/json, text/plain, */*'
    });
    return Promise.resolve(options);
  }

  protected transformResult(url: string, response: any, processResponse: (r: HttpResponseBase) => Observable<any>): Observable<any> {
    return from(processResponse(response)).pipe(catchError(error => {
      return this.handleError(error, () => processResponse(response));
    }));
  }

  public refreshLogin(): Observable<any> {
    return this.authService.refreshLogin().pipe(
      catchError(error => {
        return this.handleError(error, () => this.refreshLogin());
      }));
  }

  private handleError(error: any, continuation: () => Observable<any>): Observable<any> {
    if (error.status == 401) {
      if (this.isRefreshingLogin) {
        return this.pauseTask(continuation);
      }

      this.isRefreshingLogin = true;

      return from(this.authService.refreshLogin()).pipe(
        mergeMap(() => {
          this.isRefreshingLogin = false;
          this.resumeTasks(true);

          return continuation();
        }),
        catchError(refreshLoginError => {
          this.isRefreshingLogin = false;
          this.resumeTasks(false);
          this.authService.reLogin();

          if (refreshLoginError.status == 401 || (refreshLoginError.error && refreshLoginError.error.error == 'invalid_grant')) {
            return throwError('session expired');
          } else {
            return throwError(refreshLoginError || 'server error');
          }
        }));
    }

    if (error.error && error.error.error == 'invalid_grant') {
      this.authService.reLogin();

      return throwError((error.error && error.error.error_description) ? `session expired (${error.error.error_description})` : 'session expired');
    } else {
      return throwError(error);
    }
  }

  private pauseTask(continuation: () => Observable<any>): Observable<any> {
    if (!this.taskPauser) {
      this.taskPauser = new Subject();
    }

    return this.taskPauser.pipe(switchMap(continueOp => {
      return continueOp ? continuation() : throwError('session expired');
    }));
  }

  private resumeTasks(continueOp: boolean): void {
    setTimeout(() => {
      if (this.taskPauser) {
        this.taskPauser.next(continueOp);
        this.taskPauser.complete();
        this.taskPauser = null;
      }
    });
  }
}

@Injectable()
export class AccountEndpointService extends BaseEndpointService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(ConfigurationService) configService: ConfigurationService, @Inject(AuthEndpointService) authService: AuthEndpointService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    super(configService, authService);
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
  }

  getCurrentUser(): Observable<UserViewModel> {
    let url_ = this.baseUrl + "/Account/users/me";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetCurrentUser(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetCurrentUser(<any>r));
        } catch (e) {
          return <Observable<UserViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processGetCurrentUser(response: HttpResponseBase): Observable<UserViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserViewModel>(<any>null);
  }

  updateCurrentUser(user: UserEditViewModel): Observable<void> {
    let url_ = this.baseUrl + "/Account/users/me";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(user);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processUpdateCurrentUser(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processUpdateCurrentUser(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processUpdateCurrentUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ProblemDetails.fromJS(resultData403);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  updateCurrentUser2(patch: Operation[]): Observable<void> {
    let url_ = this.baseUrl + "/Account/users/me";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processUpdateCurrentUser2(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processUpdateCurrentUser2(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processUpdateCurrentUser2(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  getUserById(id: string | null): Observable<UserViewModel> {
    let url_ = this.baseUrl + "/Account/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetUserById(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetUserById(<any>r));
        } catch (e) {
          return <Observable<UserViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processGetUserById(response: HttpResponseBase): Observable<UserViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ProblemDetails.fromJS(resultData403);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserViewModel>(<any>null);
  }

  updateUser(id: string | null, user: UserEditViewModel): Observable<void> {
    let url_ = this.baseUrl + "/Account/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(user);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processUpdateUser(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processUpdateUser(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processUpdateUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ProblemDetails.fromJS(resultData403);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  updateUser2(id: string | null, patch: Operation[]): Observable<void> {
    let url_ = this.baseUrl + "/Account/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processUpdateUser2(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processUpdateUser2(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processUpdateUser2(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ProblemDetails.fromJS(resultData403);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  deleteUser(id: string | null): Observable<UserViewModel> {
    let url_ = this.baseUrl + "/Account/users/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteUser(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteUser(<any>r));
        } catch (e) {
          return <Observable<UserViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteUser(response: HttpResponseBase): Observable<UserViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ProblemDetails.fromJS(resultData403);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserViewModel>(<any>null);
  }

  getUserByUserName(userName: string | null): Observable<UserViewModel> {
    let url_ = this.baseUrl + "/Account/users/username/{userName}";
    if (userName === undefined || userName === null)
      throw new Error("The parameter 'userName' must be defined.");
    url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetUserByUserName(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetUserByUserName(<any>r));
        } catch (e) {
          return <Observable<UserViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processGetUserByUserName(response: HttpResponseBase): Observable<UserViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = UserViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ProblemDetails.fromJS(resultData403);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserViewModel>(<any>null);
  }

  getUsersAll(): Observable<UserViewModel[]> {
    let url_ = this.baseUrl + "/Account/users";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetUsersAll(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetUsersAll(<any>r));
        } catch (e) {
          return <Observable<UserViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetUsersAll(response: HttpResponseBase): Observable<UserViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(UserViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserViewModel[]>(<any>null);
  }

  register(user: UserEditViewModel): Observable<UserViewModel> {
    let url_ = this.baseUrl + "/Account/users";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(user);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processRegister(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processRegister(<any>r));
        } catch (e) {
          return <Observable<UserViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processRegister(response: HttpResponseBase): Observable<UserViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = UserViewModel.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ProblemDetails.fromJS(resultData403);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserViewModel>(<any>null);
  }

  getUsers(pageNumber: number, pageSize: number): Observable<UserViewModel[]> {
    let url_ = this.baseUrl + "/Account/users/{pageNumber}/{pageSize}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetUsers(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetUsers(<any>r));
        } catch (e) {
          return <Observable<UserViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<UserViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetUsers(response: HttpResponseBase): Observable<UserViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(UserViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<UserViewModel[]>(<any>null);
  }

  unblockUser(id: string | null): Observable<void> {
    let url_ = this.baseUrl + "/Account/users/unblock/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processUnblockUser(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processUnblockUser(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processUnblockUser(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  userPreferences(): Observable<string> {
    let url_ = this.baseUrl + "/Account/users/me/preferences";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processUserPreferences(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processUserPreferences(<any>r));
        } catch (e) {
          return <Observable<string>><any>_observableThrow(e);
        }
      } else
        return <Observable<string>><any>_observableThrow(response_);
    }));
  }

  protected processUserPreferences(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = resultData200 !== undefined ? resultData200 : <any>null;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<string>(<any>null);
  }

  userPreferences2(data: string): Observable<void> {
    let url_ = this.baseUrl + "/Account/users/me/preferences";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(data);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processUserPreferences2(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processUserPreferences2(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processUserPreferences2(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  getRoleById(id: string | null): Observable<RoleViewModel> {
    let url_ = this.baseUrl + "/Account/roles/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetRoleById(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetRoleById(<any>r));
        } catch (e) {
          return <Observable<RoleViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<RoleViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processGetRoleById(response: HttpResponseBase): Observable<RoleViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RoleViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ProblemDetails.fromJS(resultData403);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RoleViewModel>(<any>null);
  }

  updateRole(id: string | null, role: RoleViewModel): Observable<void> {
    let url_ = this.baseUrl + "/Account/roles/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(role);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processUpdateRole(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processUpdateRole(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processUpdateRole(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  deleteRole(id: string | null): Observable<RoleViewModel> {
    let url_ = this.baseUrl + "/Account/roles/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteRole(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteRole(<any>r));
        } catch (e) {
          return <Observable<RoleViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<RoleViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteRole(response: HttpResponseBase): Observable<RoleViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RoleViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RoleViewModel>(<any>null);
  }

  getRoleByName(name: string | null): Observable<RoleViewModel> {
    let url_ = this.baseUrl + "/Account/roles/name/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetRoleByName(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetRoleByName(<any>r));
        } catch (e) {
          return <Observable<RoleViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<RoleViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processGetRoleByName(response: HttpResponseBase): Observable<RoleViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = RoleViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 403) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result403: any = null;
        let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result403 = ProblemDetails.fromJS(resultData403);
        return throwException("A server side error occurred.", status, _responseText, _headers, result403);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RoleViewModel>(<any>null);
  }

  getRolesAll(): Observable<RoleViewModel[]> {
    let url_ = this.baseUrl + "/Account/roles";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetRolesAll(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetRolesAll(<any>r));
        } catch (e) {
          return <Observable<RoleViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<RoleViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetRolesAll(response: HttpResponseBase): Observable<RoleViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(RoleViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RoleViewModel[]>(<any>null);
  }

  createRole(role: RoleViewModel): Observable<RoleViewModel> {
    let url_ = this.baseUrl + "/Account/roles";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(role);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processCreateRole(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processCreateRole(<any>r));
        } catch (e) {
          return <Observable<RoleViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<RoleViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processCreateRole(response: HttpResponseBase): Observable<RoleViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = RoleViewModel.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RoleViewModel>(<any>null);
  }

  getRoles(pageNumber: number, pageSize: number): Observable<RoleViewModel[]> {
    let url_ = this.baseUrl + "/Account/roles/{pageNumber}/{pageSize}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetRoles(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetRoles(<any>r));
        } catch (e) {
          return <Observable<RoleViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<RoleViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetRoles(response: HttpResponseBase): Observable<RoleViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(RoleViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<RoleViewModel[]>(<any>null);
  }

  getAllPermissions(): Observable<PermissionViewModel[]> {
    let url_ = this.baseUrl + "/Account/permissions";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllPermissions(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllPermissions(<any>r));
        } catch (e) {
          return <Observable<PermissionViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<PermissionViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(PermissionViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<PermissionViewModel[]>(<any>null);
  }
}

@Injectable()
export class EventEndpointService extends BaseEndpointService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(ConfigurationService) configService: ConfigurationService, @Inject(AuthEndpointService) authService: AuthEndpointService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    super(configService, authService);
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
  }

  getAllEvents(includePropertyPaths: string | null): Observable<Event[]> {
    let url_ = this.baseUrl + "/Event/{includePropertyPaths}";
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEvents(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEvents(<any>r));
        } catch (e) {
          return <Observable<Event[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<Event[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEvents(response: HttpResponseBase): Observable<Event[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Event.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Event[]>(<any>null);
  }

  getAllEventsPaged(pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<Event[]> {
    let url_ = this.baseUrl + "/Event/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventsPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventsPaged(<any>r));
        } catch (e) {
          return <Observable<Event[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<Event[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventsPaged(response: HttpResponseBase): Observable<Event[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Event.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Event[]>(<any>null);
  }

  getEvent(id: string | null, includePropertyPaths: string | null): Observable<Event> {
    let url_ = this.baseUrl + "/Event/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetEvent(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetEvent(<any>r));
        } catch (e) {
          return <Observable<Event>><any>_observableThrow(e);
        }
      } else
        return <Observable<Event>><any>_observableThrow(response_);
    }));
  }

  protected processGetEvent(response: HttpResponseBase): Observable<Event> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Event.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Event>(<any>null);
  }

  putEvent(id: string | null, includePropertyPaths: string | null, entity: Event): Observable<Event> {
    let url_ = this.baseUrl + "/Event/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPutEvent(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPutEvent(<any>r));
        } catch (e) {
          return <Observable<Event>><any>_observableThrow(e);
        }
      } else
        return <Observable<Event>><any>_observableThrow(response_);
    }));
  }

  protected processPutEvent(response: HttpResponseBase): Observable<Event> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Event.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Event>(<any>null);
  }

  patchEvent(id: string | null, includePropertyPaths: string | null, patch: Operation[]): Observable<Event> {
    let url_ = this.baseUrl + "/Event/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPatchEvent(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPatchEvent(<any>r));
        } catch (e) {
          return <Observable<Event>><any>_observableThrow(e);
        }
      } else
        return <Observable<Event>><any>_observableThrow(response_);
    }));
  }

  protected processPatchEvent(response: HttpResponseBase): Observable<Event> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Event.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Event>(<any>null);
  }

  deleteEvent(id: string | null): Observable<void> {
    let url_ = this.baseUrl + "/Event/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteEvent(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteEvent(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteEvent(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  postEvent(entity: Event): Observable<Event> {
    let url_ = this.baseUrl + "/Event";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPostEvent(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPostEvent(<any>r));
        } catch (e) {
          return <Observable<Event>><any>_observableThrow(e);
        }
      } else
        return <Observable<Event>><any>_observableThrow(response_);
    }));
  }

  protected processPostEvent(response: HttpResponseBase): Observable<Event> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = Event.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Event>(<any>null);
  }

  getAllEventLocations(includePropertyPaths: string | null): Observable<EventLocation[]> {
    let url_ = this.baseUrl + "/Event/Location/{includePropertyPaths}";
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventLocations(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventLocations(<any>r));
        } catch (e) {
          return <Observable<EventLocation[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventLocation[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventLocations(response: HttpResponseBase): Observable<EventLocation[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventLocation.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventLocation[]>(<any>null);
  }

  getAllEventLocationsPaged(pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventLocation[]> {
    let url_ = this.baseUrl + "/Event/Location/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsPaged(<any>r));
        } catch (e) {
          return <Observable<EventLocation[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventLocation[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventLocationsPaged(response: HttpResponseBase): Observable<EventLocation[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventLocation.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventLocation[]>(<any>null);
  }

  getAllEventLocationsByEvent(eventId: string | null, includePropertyPaths: string | null): Observable<EventLocation[]> {
    let url_ = this.baseUrl + "/Event/{eventId}/Location/{includePropertyPaths}";
    if (eventId === undefined || eventId === null)
      throw new Error("The parameter 'eventId' must be defined.");
    url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEvent(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEvent(<any>r));
        } catch (e) {
          return <Observable<EventLocation[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventLocation[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventLocationsByEvent(response: HttpResponseBase): Observable<EventLocation[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventLocation.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventLocation[]>(<any>null);
  }

  getAllEventLocationsByEventPaged(eventId: string | null, pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventLocation[]> {
    let url_ = this.baseUrl + "/Event/{eventId}/Location/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (eventId === undefined || eventId === null)
      throw new Error("The parameter 'eventId' must be defined.");
    url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventPaged(<any>r));
        } catch (e) {
          return <Observable<EventLocation[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventLocation[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventLocationsByEventPaged(response: HttpResponseBase): Observable<EventLocation[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventLocation.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventLocation[]>(<any>null);
  }

  getAllEventLocationsByEventSchedule(eventScheduleId: string | null, includePropertyPaths: string | null): Observable<EventLocation[]> {
    let url_ = this.baseUrl + "/Event/Location/Schedule/{eventScheduleId}/{includePropertyPaths}";
    if (eventScheduleId === undefined || eventScheduleId === null)
      throw new Error("The parameter 'eventScheduleId' must be defined.");
    url_ = url_.replace("{eventScheduleId}", encodeURIComponent("" + eventScheduleId));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventSchedule(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventSchedule(<any>r));
        } catch (e) {
          return <Observable<EventLocation[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventLocation[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventLocationsByEventSchedule(response: HttpResponseBase): Observable<EventLocation[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventLocation.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventLocation[]>(<any>null);
  }

  getAllEventLocationsByEventSchedulePaged(eventScheduleId: string | null, pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventLocation[]> {
    let url_ = this.baseUrl + "/Event/Location/Schedule/{eventScheduleId}/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (eventScheduleId === undefined || eventScheduleId === null)
      throw new Error("The parameter 'eventScheduleId' must be defined.");
    url_ = url_.replace("{eventScheduleId}", encodeURIComponent("" + eventScheduleId));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventSchedulePaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventLocationsByEventSchedulePaged(<any>r));
        } catch (e) {
          return <Observable<EventLocation[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventLocation[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventLocationsByEventSchedulePaged(response: HttpResponseBase): Observable<EventLocation[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventLocation.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventLocation[]>(<any>null);
  }

  getEventLocation(id: string | null, includePropertyPaths: string | null): Observable<EventLocation> {
    let url_ = this.baseUrl + "/Event/Location/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetEventLocation(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetEventLocation(<any>r));
        } catch (e) {
          return <Observable<EventLocation>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventLocation>><any>_observableThrow(response_);
    }));
  }

  protected processGetEventLocation(response: HttpResponseBase): Observable<EventLocation> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventLocation.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventLocation>(<any>null);
  }

  putEventLocation(id: string | null, includePropertyPaths: string | null, entity: EventLocation): Observable<EventLocation> {
    let url_ = this.baseUrl + "/Event/Location/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPutEventLocation(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPutEventLocation(<any>r));
        } catch (e) {
          return <Observable<EventLocation>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventLocation>><any>_observableThrow(response_);
    }));
  }

  protected processPutEventLocation(response: HttpResponseBase): Observable<EventLocation> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventLocation.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventLocation>(<any>null);
  }

  patchEventLocation(id: string | null, includePropertyPaths: string | null, patch: Operation[]): Observable<EventLocation> {
    let url_ = this.baseUrl + "/Event/Location/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPatchEventLocation(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPatchEventLocation(<any>r));
        } catch (e) {
          return <Observable<EventLocation>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventLocation>><any>_observableThrow(response_);
    }));
  }

  protected processPatchEventLocation(response: HttpResponseBase): Observable<EventLocation> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventLocation.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventLocation>(<any>null);
  }

  deleteEventLocation(id: string | null): Observable<void> {
    let url_ = this.baseUrl + "/Event/Location/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteEventLocation(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteEventLocation(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteEventLocation(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  postEventLocation(entity: EventLocation): Observable<EventLocation> {
    let url_ = this.baseUrl + "/Event/Location";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPostEventLocation(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPostEventLocation(<any>r));
        } catch (e) {
          return <Observable<EventLocation>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventLocation>><any>_observableThrow(response_);
    }));
  }

  protected processPostEventLocation(response: HttpResponseBase): Observable<EventLocation> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = EventLocation.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventLocation>(<any>null);
  }

  getAllEventSchedules(includePropertyPaths: string | null): Observable<EventSchedule[]> {
    let url_ = this.baseUrl + "/Event/Schedule/{includePropertyPaths}";
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedules(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedules(<any>r));
        } catch (e) {
          return <Observable<EventSchedule[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventSchedules(response: HttpResponseBase): Observable<EventSchedule[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventSchedule.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule[]>(<any>null);
  }

  getAllEventSchedulesPaged(pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventSchedule[]> {
    let url_ = this.baseUrl + "/Event/Schedule/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesPaged(<any>r));
        } catch (e) {
          return <Observable<EventSchedule[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventSchedulesPaged(response: HttpResponseBase): Observable<EventSchedule[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventSchedule.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule[]>(<any>null);
  }

  getAllEventSchedulesByEvent(eventId: string | null, includePropertyPaths: string | null): Observable<EventSchedule[]> {
    let url_ = this.baseUrl + "/Event/{eventId}/Schedule/{includePropertyPaths}";
    if (eventId === undefined || eventId === null)
      throw new Error("The parameter 'eventId' must be defined.");
    url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEvent(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEvent(<any>r));
        } catch (e) {
          return <Observable<EventSchedule[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventSchedulesByEvent(response: HttpResponseBase): Observable<EventSchedule[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventSchedule.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule[]>(<any>null);
  }

  getAllEventSchedulesByEventPaged(eventId: string | null, pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventSchedule[]> {
    let url_ = this.baseUrl + "/Event/{eventId}/Schedule/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (eventId === undefined || eventId === null)
      throw new Error("The parameter 'eventId' must be defined.");
    url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventPaged(<any>r));
        } catch (e) {
          return <Observable<EventSchedule[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventSchedulesByEventPaged(response: HttpResponseBase): Observable<EventSchedule[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventSchedule.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule[]>(<any>null);
  }

  getAllEventSchedulesByEventLocation(eventLocationId: string | null, includePropertyPaths: string | null): Observable<EventSchedule[]> {
    let url_ = this.baseUrl + "/Event/Schedule/Location/{eventLocationId}/{includePropertyPaths}";
    if (eventLocationId === undefined || eventLocationId === null)
      throw new Error("The parameter 'eventLocationId' must be defined.");
    url_ = url_.replace("{eventLocationId}", encodeURIComponent("" + eventLocationId));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventLocation(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventLocation(<any>r));
        } catch (e) {
          return <Observable<EventSchedule[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventSchedulesByEventLocation(response: HttpResponseBase): Observable<EventSchedule[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventSchedule.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule[]>(<any>null);
  }

  getAllEventSchedulesByEventLocationPaged(eventLocationId: string | null, pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventSchedule[]> {
    let url_ = this.baseUrl + "/Event/Schedule/Location/{eventLocationId}/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (eventLocationId === undefined || eventLocationId === null)
      throw new Error("The parameter 'eventLocationId' must be defined.");
    url_ = url_.replace("{eventLocationId}", encodeURIComponent("" + eventLocationId));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventLocationPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventSchedulesByEventLocationPaged(<any>r));
        } catch (e) {
          return <Observable<EventSchedule[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventSchedulesByEventLocationPaged(response: HttpResponseBase): Observable<EventSchedule[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventSchedule.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule[]>(<any>null);
  }

  getEventSchedule(id: string | null, includePropertyPaths: string | null): Observable<EventSchedule> {
    let url_ = this.baseUrl + "/Event/Schedule/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetEventSchedule(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetEventSchedule(<any>r));
        } catch (e) {
          return <Observable<EventSchedule>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule>><any>_observableThrow(response_);
    }));
  }

  protected processGetEventSchedule(response: HttpResponseBase): Observable<EventSchedule> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventSchedule.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule>(<any>null);
  }

  putEventSchedule(id: string | null, includePropertyPaths: string | null, entity: EventSchedule): Observable<EventSchedule> {
    let url_ = this.baseUrl + "/Event/Schedule/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPutEventSchedule(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPutEventSchedule(<any>r));
        } catch (e) {
          return <Observable<EventSchedule>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule>><any>_observableThrow(response_);
    }));
  }

  protected processPutEventSchedule(response: HttpResponseBase): Observable<EventSchedule> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventSchedule.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule>(<any>null);
  }

  patchEventSchedule(id: string | null, includePropertyPaths: string | null, patch: Operation[]): Observable<EventSchedule> {
    let url_ = this.baseUrl + "/Event/Schedule/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPatchEventSchedule(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPatchEventSchedule(<any>r));
        } catch (e) {
          return <Observable<EventSchedule>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule>><any>_observableThrow(response_);
    }));
  }

  protected processPatchEventSchedule(response: HttpResponseBase): Observable<EventSchedule> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventSchedule.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule>(<any>null);
  }

  deleteEventSchedule(id: string | null): Observable<void> {
    let url_ = this.baseUrl + "/Event/Schedule/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteEventSchedule(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteEventSchedule(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteEventSchedule(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  postEventSchedule(entity: EventSchedule): Observable<EventSchedule> {
    let url_ = this.baseUrl + "/Event/Schedule";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPostEventSchedule(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPostEventSchedule(<any>r));
        } catch (e) {
          return <Observable<EventSchedule>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule>><any>_observableThrow(response_);
    }));
  }

  protected processPostEventSchedule(response: HttpResponseBase): Observable<EventSchedule> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = EventSchedule.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule>(<any>null);
  }

  getAllEventOccurrences(includePropertyPaths: string | null): Observable<EventOccurance[]> {
    let url_ = this.baseUrl + "/Event/Occurrence/{includePropertyPaths}";
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrences(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrences(<any>r));
        } catch (e) {
          return <Observable<EventOccurance[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventOccurance[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventOccurrences(response: HttpResponseBase): Observable<EventOccurance[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventOccurance.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventOccurance[]>(<any>null);
  }

  getAllEventOccurrencesPaged(pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventOccurance[]> {
    let url_ = this.baseUrl + "/Event/Occurrence/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesPaged(<any>r));
        } catch (e) {
          return <Observable<EventOccurance[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventOccurance[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventOccurrencesPaged(response: HttpResponseBase): Observable<EventOccurance[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventOccurance.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventOccurance[]>(<any>null);
  }

  getAllEventOccurrencesByEvent(eventId: string | null, includePropertyPaths: string | null): Observable<EventOccurance[]> {
    let url_ = this.baseUrl + "/Event/{eventId}/Occurrence/{includePropertyPaths}";
    if (eventId === undefined || eventId === null)
      throw new Error("The parameter 'eventId' must be defined.");
    url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEvent(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEvent(<any>r));
        } catch (e) {
          return <Observable<EventOccurance[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventOccurance[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventOccurrencesByEvent(response: HttpResponseBase): Observable<EventOccurance[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventOccurance.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventOccurance[]>(<any>null);
  }

  getAllEventOccurrencesByEventPaged(eventId: string | null, pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventOccurance[]> {
    let url_ = this.baseUrl + "/Event/{eventId}/Occurrence/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (eventId === undefined || eventId === null)
      throw new Error("The parameter 'eventId' must be defined.");
    url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventPaged(<any>r));
        } catch (e) {
          return <Observable<EventOccurance[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventOccurance[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventOccurrencesByEventPaged(response: HttpResponseBase): Observable<EventOccurance[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventOccurance.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventOccurance[]>(<any>null);
  }

  getAllEventOccurrencesByEventLocation(eventLocationId: string | null, includePropertyPaths: string | null): Observable<EventOccurance[]> {
    let url_ = this.baseUrl + "/Event/Occurrence/Location/{eventLocationid}/{includePropertyPaths}";
    if (eventLocationId === undefined || eventLocationId === null)
      throw new Error("The parameter 'eventLocationId' must be defined.");
    url_ = url_.replace("{eventLocationId}", encodeURIComponent("" + eventLocationId));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventLocation(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventLocation(<any>r));
        } catch (e) {
          return <Observable<EventOccurance[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventOccurance[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventOccurrencesByEventLocation(response: HttpResponseBase): Observable<EventOccurance[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventOccurance.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventOccurance[]>(<any>null);
  }

  getAllEventOccurrencesByEventLocationPaged(eventLocationId: string | null, pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventSchedule[]> {
    let url_ = this.baseUrl + "/Event/Occurrence/Location/{eventLocationid}/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (eventLocationId === undefined || eventLocationId === null)
      throw new Error("The parameter 'eventLocationId' must be defined.");
    url_ = url_.replace("{eventLocationId}", encodeURIComponent("" + eventLocationId));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventLocationPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventLocationPaged(<any>r));
        } catch (e) {
          return <Observable<EventSchedule[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventOccurrencesByEventLocationPaged(response: HttpResponseBase): Observable<EventSchedule[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventSchedule.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule[]>(<any>null);
  }

  getAllEventOccurrencesByEventSchedule(eventScheduleId: string | null, includePropertyPaths: string | null): Observable<EventOccurance[]> {
    let url_ = this.baseUrl + "/Event/Occurrence/Schedule/{eventScheduleid}/{includePropertyPaths}";
    if (eventScheduleId === undefined || eventScheduleId === null)
      throw new Error("The parameter 'eventScheduleId' must be defined.");
    url_ = url_.replace("{eventScheduleId}", encodeURIComponent("" + eventScheduleId));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventSchedule(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventSchedule(<any>r));
        } catch (e) {
          return <Observable<EventOccurance[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventOccurance[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventOccurrencesByEventSchedule(response: HttpResponseBase): Observable<EventOccurance[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventOccurance.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventOccurance[]>(<any>null);
  }

  getAllEventOccurrencesByEventSchedulePaged(eventScheduleid: string | null, pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventSchedule[]> {
    let url_ = this.baseUrl + "/Event/Occurrence/Schedule/{eventScheduleid}/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (eventScheduleid === undefined || eventScheduleid === null)
      throw new Error("The parameter 'eventScheduleid' must be defined.");
    url_ = url_.replace("{eventScheduleid}", encodeURIComponent("" + eventScheduleid));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventSchedulePaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventOccurrencesByEventSchedulePaged(<any>r));
        } catch (e) {
          return <Observable<EventSchedule[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventSchedule[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventOccurrencesByEventSchedulePaged(response: HttpResponseBase): Observable<EventSchedule[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventSchedule.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventSchedule[]>(<any>null);
  }

  getEventOccurrence(id: string | null, includePropertyPaths: string | null): Observable<EventOccurance> {
    let url_ = this.baseUrl + "/Event/Occurrence/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetEventOccurrence(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetEventOccurrence(<any>r));
        } catch (e) {
          return <Observable<EventOccurance>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventOccurance>><any>_observableThrow(response_);
    }));
  }

  protected processGetEventOccurrence(response: HttpResponseBase): Observable<EventOccurance> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventOccurance.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventOccurance>(<any>null);
  }

  putEventOccurrence(id: string | null, includePropertyPaths: string | null, entity: EventOccurance): Observable<EventOccurance> {
    let url_ = this.baseUrl + "/Event/Occurrence/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPutEventOccurrence(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPutEventOccurrence(<any>r));
        } catch (e) {
          return <Observable<EventOccurance>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventOccurance>><any>_observableThrow(response_);
    }));
  }

  protected processPutEventOccurrence(response: HttpResponseBase): Observable<EventOccurance> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventOccurance.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventOccurance>(<any>null);
  }

  patchEventOccurrence(id: string | null, includePropertyPaths: string | null, patch: Operation[]): Observable<EventOccurance> {
    let url_ = this.baseUrl + "/Event/Occurrence/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPatchEventOccurrence(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPatchEventOccurrence(<any>r));
        } catch (e) {
          return <Observable<EventOccurance>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventOccurance>><any>_observableThrow(response_);
    }));
  }

  protected processPatchEventOccurrence(response: HttpResponseBase): Observable<EventOccurance> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventOccurance.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventOccurance>(<any>null);
  }

  deleteEventOccurrence(id: string | null): Observable<void> {
    let url_ = this.baseUrl + "/Event/Occurrence/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteEventOccurrence(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteEventOccurrence(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteEventOccurrence(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  postEventOccurrence(entity: EventOccurance): Observable<EventOccurance> {
    let url_ = this.baseUrl + "/Event/Occurrence";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPostEventOccurrence(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPostEventOccurrence(<any>r));
        } catch (e) {
          return <Observable<EventOccurance>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventOccurance>><any>_observableThrow(response_);
    }));
  }

  protected processPostEventOccurrence(response: HttpResponseBase): Observable<EventOccurance> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = EventOccurance.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventOccurance>(<any>null);
  }

  getAllEventServices(includePropertyPaths: string | null): Observable<EventService[]> {
    let url_ = this.baseUrl + "/Event/Service/{includePropertyPaths}";
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventServices(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventServices(<any>r));
        } catch (e) {
          return <Observable<EventService[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventService[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventServices(response: HttpResponseBase): Observable<EventService[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventService.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventService[]>(<any>null);
  }

  getAllEventServicesPaged(pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventService[]> {
    let url_ = this.baseUrl + "/Event/Service/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesPaged(<any>r));
        } catch (e) {
          return <Observable<EventService[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventService[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventServicesPaged(response: HttpResponseBase): Observable<EventService[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventService.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventService[]>(<any>null);
  }

  getAllEventServicesByEvent(eventId: string | null, includePropertyPaths: string | null): Observable<EventService[]> {
    let url_ = this.baseUrl + "/Event/{eventId}/Service/{includePropertyPaths}";
    if (eventId === undefined || eventId === null)
      throw new Error("The parameter 'eventId' must be defined.");
    url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByEvent(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByEvent(<any>r));
        } catch (e) {
          return <Observable<EventService[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventService[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventServicesByEvent(response: HttpResponseBase): Observable<EventService[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventService.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventService[]>(<any>null);
  }

  getAllEventServicesByEventPaged(eventId: string | null, pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventService[]> {
    let url_ = this.baseUrl + "/Event/{eventId}/Service/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (eventId === undefined || eventId === null)
      throw new Error("The parameter 'eventId' must be defined.");
    url_ = url_.replace("{eventId}", encodeURIComponent("" + eventId));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByEventPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByEventPaged(<any>r));
        } catch (e) {
          return <Observable<EventService[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventService[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventServicesByEventPaged(response: HttpResponseBase): Observable<EventService[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventService.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventService[]>(<any>null);
  }

  getAllEventServicesByService(serviceId: string | null, includePropertyPaths: string | null): Observable<EventService[]> {
    let url_ = this.baseUrl + "/Event/Service/Service/{serviceId}/{includePropertyPaths}";
    if (serviceId === undefined || serviceId === null)
      throw new Error("The parameter 'serviceId' must be defined.");
    url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByService(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByService(<any>r));
        } catch (e) {
          return <Observable<EventService[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventService[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventServicesByService(response: HttpResponseBase): Observable<EventService[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventService.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventService[]>(<any>null);
  }

  getAllEventServicesByServicePaged(serviceId: string | null, pageNumber: number, pageSize: number, includePropertyPaths: string | null): Observable<EventService[]> {
    let url_ = this.baseUrl + "/Event/Service/Service/{serviceId}/{pageNumber}/{pageSize}/{includePropertyPaths}";
    if (serviceId === undefined || serviceId === null)
      throw new Error("The parameter 'serviceId' must be defined.");
    url_ = url_.replace("{serviceId}", encodeURIComponent("" + serviceId));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByServicePaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllEventServicesByServicePaged(<any>r));
        } catch (e) {
          return <Observable<EventService[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventService[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllEventServicesByServicePaged(response: HttpResponseBase): Observable<EventService[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(EventService.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventService[]>(<any>null);
  }

  getEventService(id: string | null, includePropertyPaths: string | null): Observable<EventService> {
    let url_ = this.baseUrl + "/Event/Service/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetEventService(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetEventService(<any>r));
        } catch (e) {
          return <Observable<EventService>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventService>><any>_observableThrow(response_);
    }));
  }

  protected processGetEventService(response: HttpResponseBase): Observable<EventService> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventService.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventService>(<any>null);
  }

  putEventService(id: string | null, includePropertyPaths: string | null, entity: EventService): Observable<EventService> {
    let url_ = this.baseUrl + "/Event/Service/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPutEventService(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPutEventService(<any>r));
        } catch (e) {
          return <Observable<EventService>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventService>><any>_observableThrow(response_);
    }));
  }

  protected processPutEventService(response: HttpResponseBase): Observable<EventService> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventService.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventService>(<any>null);
  }

  patchEventService(id: string | null, includePropertyPaths: string | null, patch: Operation[]): Observable<EventService> {
    let url_ = this.baseUrl + "/Event/Service/{id}/{includePropertyPaths}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (includePropertyPaths === undefined || includePropertyPaths === null)
      throw new Error("The parameter 'includePropertyPaths' must be defined.");
    url_ = url_.replace("{includePropertyPaths}", encodeURIComponent("" + includePropertyPaths));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPatchEventService(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPatchEventService(<any>r));
        } catch (e) {
          return <Observable<EventService>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventService>><any>_observableThrow(response_);
    }));
  }

  protected processPatchEventService(response: HttpResponseBase): Observable<EventService> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = EventService.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventService>(<any>null);
  }

  deleteEventService(id: string | null): Observable<void> {
    let url_ = this.baseUrl + "/Event/Service/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteEventService(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteEventService(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteEventService(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  postEventService(entity: EventService): Observable<EventService> {
    let url_ = this.baseUrl + "/Event/Service";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPostEventService(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPostEventService(<any>r));
        } catch (e) {
          return <Observable<EventService>><any>_observableThrow(e);
        }
      } else
        return <Observable<EventService>><any>_observableThrow(response_);
    }));
  }

  protected processPostEventService(response: HttpResponseBase): Observable<EventService> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = EventService.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<EventService>(<any>null);
  }
}

@Injectable()
export class ExtendedLogEndpointService extends BaseEndpointService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(ConfigurationService) configService: ConfigurationService, @Inject(AuthEndpointService) authService: AuthEndpointService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    super(configService, authService);
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
  }

  getAll(): Observable<ExtendedLogViewModel[]> {
    let url_ = this.baseUrl + "/ExtendedLog";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAll(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAll(<any>r));
        } catch (e) {
          return <Observable<ExtendedLogViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLogViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<ExtendedLogViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ExtendedLogViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLogViewModel[]>(<any>null);
  }

  deleteAll(): Observable<void> {
    let url_ = this.baseUrl + "/ExtendedLog";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteAll(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteAll(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteAll(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  post(extendedLogVM: ExtendedLogViewModel): Observable<ExtendedLogViewModel> {
    let url_ = this.baseUrl + "/ExtendedLog";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(extendedLogVM);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPost(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPost(<any>r));
        } catch (e) {
          return <Observable<ExtendedLogViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLogViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processPost(response: HttpResponseBase): Observable<ExtendedLogViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = ExtendedLogViewModel.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLogViewModel>(<any>null);
  }

  getAllPaged(pageNumber: number, pageSize: number): Observable<ExtendedLogViewModel[]> {
    let url_ = this.baseUrl + "/ExtendedLog/{pageNumber}/{pageSize}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllPaged(<any>r));
        } catch (e) {
          return <Observable<ExtendedLogViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLogViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllPaged(response: HttpResponseBase): Observable<ExtendedLogViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ExtendedLogViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLogViewModel[]>(<any>null);
  }

  getByLevel(level: number): Observable<ExtendedLogViewModel[]> {
    let url_ = this.baseUrl + "/ExtendedLog/level/{level}";
    if (level === undefined || level === null)
      throw new Error("The parameter 'level' must be defined.");
    url_ = url_.replace("{level}", encodeURIComponent("" + level));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetByLevel(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetByLevel(<any>r));
        } catch (e) {
          return <Observable<ExtendedLogViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLogViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetByLevel(response: HttpResponseBase): Observable<ExtendedLogViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ExtendedLogViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLogViewModel[]>(<any>null);
  }

  getByLevelPaged(level: number, pageNumber: number, pageSize: number): Observable<ExtendedLogViewModel[]> {
    let url_ = this.baseUrl + "/ExtendedLog/level/{level}/{pageNumber}/{pageSize}";
    if (level === undefined || level === null)
      throw new Error("The parameter 'level' must be defined.");
    url_ = url_.replace("{level}", encodeURIComponent("" + level));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetByLevelPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetByLevelPaged(<any>r));
        } catch (e) {
          return <Observable<ExtendedLogViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLogViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetByLevelPaged(response: HttpResponseBase): Observable<ExtendedLogViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ExtendedLogViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLogViewModel[]>(<any>null);
  }

  get(id: string | null): Observable<ExtendedLogViewModel> {
    let url_ = this.baseUrl + "/ExtendedLog/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGet(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGet(<any>r));
        } catch (e) {
          return <Observable<ExtendedLogViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLogViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<ExtendedLogViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ExtendedLogViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLogViewModel>(<any>null);
  }

  delete(id: string | null): Observable<ExtendedLogViewModel> {
    let url_ = this.baseUrl + "/ExtendedLog/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDelete(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDelete(<any>r));
        } catch (e) {
          return <Observable<ExtendedLogViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLogViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<ExtendedLogViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ExtendedLogViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLogViewModel>(<any>null);
  }

  put(id: string | null, extendedLogVM: ExtendedLogViewModel): Observable<void> {
    let url_ = this.baseUrl + "/ExtendedLog/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(extendedLogVM);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPut(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPut(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  patch(id: string | null, patch: Operation[]): Observable<void> {
    let url_ = this.baseUrl + "/ExtendedLog/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPatch(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPatch(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processPatch(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class ExtendedLogControllerNewEndpointService extends BaseEndpointService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(ConfigurationService) configService: ConfigurationService, @Inject(AuthEndpointService) authService: AuthEndpointService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    super(configService, authService);
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
  }

  getAllExtendedLogs(): Observable<ExtendedLog[]> {
    let url_ = this.baseUrl + "/ExtendedLogControllerNew";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllExtendedLogs(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllExtendedLogs(<any>r));
        } catch (e) {
          return <Observable<ExtendedLog[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLog[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllExtendedLogs(response: HttpResponseBase): Observable<ExtendedLog[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ExtendedLog.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLog[]>(<any>null);
  }

  deleteAllExtendedLogs(): Observable<void> {
    let url_ = this.baseUrl + "/ExtendedLogControllerNew";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteAllExtendedLogs(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteAllExtendedLogs(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteAllExtendedLogs(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  postExtendedLog(entity: ExtendedLog): Observable<ExtendedLog> {
    let url_ = this.baseUrl + "/ExtendedLogControllerNew";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPostExtendedLog(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPostExtendedLog(<any>r));
        } catch (e) {
          return <Observable<ExtendedLog>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLog>><any>_observableThrow(response_);
    }));
  }

  protected processPostExtendedLog(response: HttpResponseBase): Observable<ExtendedLog> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = ExtendedLog.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLog>(<any>null);
  }

  getAllExtendedLogsPaged(pageNumber: number, pageSize: number): Observable<ExtendedLog[]> {
    let url_ = this.baseUrl + "/ExtendedLogControllerNew/{pageNumber}/{pageSize}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllExtendedLogsPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllExtendedLogsPaged(<any>r));
        } catch (e) {
          return <Observable<ExtendedLog[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLog[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllExtendedLogsPaged(response: HttpResponseBase): Observable<ExtendedLog[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ExtendedLog.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLog[]>(<any>null);
  }

  getExtendedLogsByLevel(level: number): Observable<ExtendedLog[]> {
    let url_ = this.baseUrl + "/ExtendedLogControllerNew/level/{level}";
    if (level === undefined || level === null)
      throw new Error("The parameter 'level' must be defined.");
    url_ = url_.replace("{level}", encodeURIComponent("" + level));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetExtendedLogsByLevel(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetExtendedLogsByLevel(<any>r));
        } catch (e) {
          return <Observable<ExtendedLog[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLog[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetExtendedLogsByLevel(response: HttpResponseBase): Observable<ExtendedLog[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ExtendedLog.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLog[]>(<any>null);
  }

  getExtendedLogsByLevelPaged(level: number, pageNumber: number, pageSize: number): Observable<ExtendedLog[]> {
    let url_ = this.baseUrl + "/ExtendedLogControllerNew/level/{level}/{pageNumber}/{pageSize}";
    if (level === undefined || level === null)
      throw new Error("The parameter 'level' must be defined.");
    url_ = url_.replace("{level}", encodeURIComponent("" + level));
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetExtendedLogsByLevelPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetExtendedLogsByLevelPaged(<any>r));
        } catch (e) {
          return <Observable<ExtendedLog[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLog[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetExtendedLogsByLevelPaged(response: HttpResponseBase): Observable<ExtendedLog[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(ExtendedLog.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLog[]>(<any>null);
  }

  getExtendedLog(id: string | null): Observable<ExtendedLog> {
    let url_ = this.baseUrl + "/ExtendedLogControllerNew/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetExtendedLog(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetExtendedLog(<any>r));
        } catch (e) {
          return <Observable<ExtendedLog>><any>_observableThrow(e);
        }
      } else
        return <Observable<ExtendedLog>><any>_observableThrow(response_);
    }));
  }

  protected processGetExtendedLog(response: HttpResponseBase): Observable<ExtendedLog> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = ExtendedLog.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<ExtendedLog>(<any>null);
  }

  deleteExtendedLog(id: string | null): Observable<void> {
    let url_ = this.baseUrl + "/ExtendedLogControllerNew/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteExtendedLog(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteExtendedLog(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteExtendedLog(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  putExtendedLog(id: string | null, entity: ExtendedLog): Observable<void> {
    let url_ = this.baseUrl + "/ExtendedLogControllerNew/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPutExtendedLog(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPutExtendedLog(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processPutExtendedLog(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  patchExtendedLog(id: string | null, patch: Operation[]): Observable<void> {
    let url_ = this.baseUrl + "/ExtendedLogControllerNew/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPatchExtendedLog(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPatchExtendedLog(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processPatchExtendedLog(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class NotificationEndpointService extends BaseEndpointService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(ConfigurationService) configService: ConfigurationService, @Inject(AuthEndpointService) authService: AuthEndpointService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    super(configService, authService);
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
  }

  getAll(): Observable<NotificationViewModel[]> {
    let url_ = this.baseUrl + "/Notification";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAll(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAll(<any>r));
        } catch (e) {
          return <Observable<NotificationViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<NotificationViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<NotificationViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(NotificationViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<NotificationViewModel[]>(<any>null);
  }

  post(notificationVM: NotificationViewModel): Observable<NotificationViewModel> {
    let url_ = this.baseUrl + "/Notification";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(notificationVM);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPost(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPost(<any>r));
        } catch (e) {
          return <Observable<NotificationViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<NotificationViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processPost(response: HttpResponseBase): Observable<NotificationViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = NotificationViewModel.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<NotificationViewModel>(<any>null);
  }

  getAllPaged(pageNumber: number, pageSize: number): Observable<NotificationViewModel[]> {
    let url_ = this.baseUrl + "/Notification/{pageNumber}/{pageSize}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllPaged(<any>r));
        } catch (e) {
          return <Observable<NotificationViewModel[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<NotificationViewModel[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllPaged(response: HttpResponseBase): Observable<NotificationViewModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(NotificationViewModel.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<NotificationViewModel[]>(<any>null);
  }

  get(id: string | null): Observable<NotificationViewModel> {
    let url_ = this.baseUrl + "/Notification/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGet(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGet(<any>r));
        } catch (e) {
          return <Observable<NotificationViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<NotificationViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<NotificationViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = NotificationViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<NotificationViewModel>(<any>null);
  }

  delete(id: string | null): Observable<NotificationViewModel> {
    let url_ = this.baseUrl + "/Notification/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDelete(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDelete(<any>r));
        } catch (e) {
          return <Observable<NotificationViewModel>><any>_observableThrow(e);
        }
      } else
        return <Observable<NotificationViewModel>><any>_observableThrow(response_);
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<NotificationViewModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = NotificationViewModel.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<NotificationViewModel>(<any>null);
  }

  put(id: string | null, notificationVM: NotificationViewModel): Observable<void> {
    let url_ = this.baseUrl + "/Notification/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(notificationVM);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPut(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPut(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processPut(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  patch(id: string | null, patch: Operation[]): Observable<void> {
    let url_ = this.baseUrl + "/Notification/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPatch(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPatch(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processPatch(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

@Injectable()
export class NotificationControllerNewEndpointService extends BaseEndpointService {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(ConfigurationService) configService: ConfigurationService, @Inject(AuthEndpointService) authService: AuthEndpointService, @Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
    super(configService, authService);
    this.http = http;
    this.baseUrl = baseUrl ? baseUrl : this.apiBaseUrl;
  }

  getAllNotifications(): Observable<Notification[]> {
    let url_ = this.baseUrl + "/NotificationControllerNew";
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllNotifications(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllNotifications(<any>r));
        } catch (e) {
          return <Observable<Notification[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<Notification[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllNotifications(response: HttpResponseBase): Observable<Notification[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Notification.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Notification[]>(<any>null);
  }

  postNotification(entity: Notification): Observable<Notification> {
    let url_ = this.baseUrl + "/NotificationControllerNew";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("post", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPostNotification(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPostNotification(<any>r));
        } catch (e) {
          return <Observable<Notification>><any>_observableThrow(e);
        }
      } else
        return <Observable<Notification>><any>_observableThrow(response_);
    }));
  }

  protected processPostNotification(response: HttpResponseBase): Observable<Notification> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 201) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result201: any = null;
        let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result201 = Notification.fromJS(resultData201);
        return _observableOf(result201);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Notification>(<any>null);
  }

  getAllNotificationsPaged(pageNumber: number, pageSize: number): Observable<Notification[]> {
    let url_ = this.baseUrl + "/NotificationControllerNew/{pageNumber}/{pageSize}";
    if (pageNumber === undefined || pageNumber === null)
      throw new Error("The parameter 'pageNumber' must be defined.");
    url_ = url_.replace("{pageNumber}", encodeURIComponent("" + pageNumber));
    if (pageSize === undefined || pageSize === null)
      throw new Error("The parameter 'pageSize' must be defined.");
    url_ = url_.replace("{pageSize}", encodeURIComponent("" + pageSize));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetAllNotificationsPaged(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetAllNotificationsPaged(<any>r));
        } catch (e) {
          return <Observable<Notification[]>><any>_observableThrow(e);
        }
      } else
        return <Observable<Notification[]>><any>_observableThrow(response_);
    }));
  }

  protected processGetAllNotificationsPaged(response: HttpResponseBase): Observable<Notification[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        if (Array.isArray(resultData200)) {
          result200 = [] as any;
          for (let item of resultData200)
            result200!.push(Notification.fromJS(item));
        }
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Notification[]>(<any>null);
  }

  getNotification(id: string | null): Observable<Notification> {
    let url_ = this.baseUrl + "/NotificationControllerNew/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("get", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processGetNotification(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processGetNotification(<any>r));
        } catch (e) {
          return <Observable<Notification>><any>_observableThrow(e);
        }
      } else
        return <Observable<Notification>><any>_observableThrow(response_);
    }));
  }

  protected processGetNotification(response: HttpResponseBase): Observable<Notification> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result200: any = null;
        let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result200 = Notification.fromJS(resultData200);
        return _observableOf(result200);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<Notification>(<any>null);
  }

  deleteNotification(id: string | null): Observable<void> {
    let url_ = this.baseUrl + "/NotificationControllerNew/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_: any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("delete", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processDeleteNotification(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processDeleteNotification(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processDeleteNotification(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 404) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result404: any = null;
        let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result404 = ProblemDetails.fromJS(resultData404);
        return throwException("A server side error occurred.", status, _responseText, _headers, result404);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  putNotification(id: string | null, entity: Notification): Observable<void> {
    let url_ = this.baseUrl + "/NotificationControllerNew/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(entity);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("put", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPutNotification(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPutNotification(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processPutNotification(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }

  patchNotification(id: string | null, patch: Operation[]): Observable<void> {
    let url_ = this.baseUrl + "/NotificationControllerNew/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(patch);

    let options_: any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return _observableFrom(this.transformOptions(options_)).pipe(_observableMergeMap(transformedOptions_ => {
      return this.http.request("patch", url_, transformedOptions_);
    })).pipe(_observableMergeMap((response_: any) => {
      return this.transformResult(url_, response_, (r) => this.processPatchNotification(<any>r));
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.transformResult(url_, response_, (r) => this.processPatchNotification(<any>r));
        } catch (e) {
          return <Observable<void>><any>_observableThrow(e);
        }
      } else
        return <Observable<void>><any>_observableThrow(response_);
    }));
  }

  protected processPatchNotification(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (<any>response).error instanceof Blob ? (<any>response).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); } }
    if (status === 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return _observableOf<void>(<any>null);
      }));
    } else if (status === 400) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        let result400: any = null;
        let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
        result400 = ProblemDetails.fromJS(resultData400);
        return throwException("A server side error occurred.", status, _responseText, _headers, result400);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf<void>(<any>null);
  }
}

export abstract class ApplicationViewModelBase implements IApplicationViewModelBase {
  createdBy?: string | undefined;
  updatedBy?: string | undefined;
  updatedDate?: Date;
  createdDate?: Date;
  rowVersion?: string | undefined;

  constructor(data?: IApplicationViewModelBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.createdBy = _data["createdBy"];
      this.updatedBy = _data["updatedBy"];
      this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.rowVersion = _data["rowVersion"];
    }
  }

  static fromJS(data: any): ApplicationViewModelBase {
    data = typeof data === 'object' ? data : {};
    throw new Error("The abstract class 'ApplicationViewModelBase' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["createdBy"] = this.createdBy;
    data["updatedBy"] = this.updatedBy;
    data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["rowVersion"] = this.rowVersion;
    return data;
  }

  clone(): ApplicationViewModelBase {
    throw new Error("The abstract class 'ApplicationViewModelBase' cannot be instantiated.");
  }
}

export interface IApplicationViewModelBase {
  createdBy?: string | undefined;
  updatedBy?: string | undefined;
  updatedDate?: Date;
  createdDate?: Date;
  rowVersion?: string | undefined;
}

export abstract class UserBaseViewModel extends ApplicationViewModelBase implements IUserBaseViewModel {
  id?: string | undefined;
  userName?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  jobTitle?: string | undefined;
  phoneNumber?: string | undefined;
  configuration?: string | undefined;
  isEnabled?: boolean;

  constructor(data?: IUserBaseViewModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.userName = _data["userName"];
      this.fullName = _data["fullName"];
      this.email = _data["email"];
      this.jobTitle = _data["jobTitle"];
      this.phoneNumber = _data["phoneNumber"];
      this.configuration = _data["configuration"];
      this.isEnabled = _data["isEnabled"];
    }
  }

  static fromJS(data: any): UserBaseViewModel {
    data = typeof data === 'object' ? data : {};
    throw new Error("The abstract class 'UserBaseViewModel' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["userName"] = this.userName;
    data["fullName"] = this.fullName;
    data["email"] = this.email;
    data["jobTitle"] = this.jobTitle;
    data["phoneNumber"] = this.phoneNumber;
    data["configuration"] = this.configuration;
    data["isEnabled"] = this.isEnabled;
    super.toJSON(data);
    return data;
  }

  clone(): UserBaseViewModel {
    throw new Error("The abstract class 'UserBaseViewModel' cannot be instantiated.");
  }
}

export interface IUserBaseViewModel extends IApplicationViewModelBase {
  id?: string | undefined;
  userName?: string | undefined;
  fullName?: string | undefined;
  email?: string | undefined;
  jobTitle?: string | undefined;
  phoneNumber?: string | undefined;
  configuration?: string | undefined;
  isEnabled?: boolean;
}

export class UserViewModel extends UserBaseViewModel implements IUserViewModel {
  isLockedOut?: boolean;
  roles?: string[] | undefined;

  constructor(data?: IUserViewModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.isLockedOut = _data["isLockedOut"];
      if (Array.isArray(_data["roles"])) {
        this.roles = [] as any;
        for (let item of _data["roles"])
          this.roles!.push(item);
      }
    }
  }

  static fromJS(data: any): UserViewModel {
    data = typeof data === 'object' ? data : {};
    let result = new UserViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["isLockedOut"] = this.isLockedOut;
    if (Array.isArray(this.roles)) {
      data["roles"] = [];
      for (let item of this.roles)
        data["roles"].push(item);
    }
    super.toJSON(data);
    return data;
  }

  clone(): UserViewModel {
    const json = this.toJSON();
    let result = new UserViewModel();
    result.init(json);
    return result;
  }
}

export interface IUserViewModel extends IUserBaseViewModel {
  isLockedOut?: boolean;
  roles?: string[] | undefined;
}

export class ProblemDetails implements IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions?: { [key: string]: any; } | undefined;

  constructor(data?: IProblemDetails) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.type = _data["type"];
      this.title = _data["title"];
      this.status = _data["status"];
      this.detail = _data["detail"];
      this.instance = _data["instance"];
      if (_data["extensions"]) {
        this.extensions = {} as any;
        for (let key in _data["extensions"]) {
          if (_data["extensions"].hasOwnProperty(key))
            this.extensions![key] = _data["extensions"][key];
        }
      }
    }
  }

  static fromJS(data: any): ProblemDetails {
    data = typeof data === 'object' ? data : {};
    let result = new ProblemDetails();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["type"] = this.type;
    data["title"] = this.title;
    data["status"] = this.status;
    data["detail"] = this.detail;
    data["instance"] = this.instance;
    if (this.extensions) {
      data["extensions"] = {};
      for (let key in this.extensions) {
        if (this.extensions.hasOwnProperty(key))
          data["extensions"][key] = this.extensions[key];
      }
    }
    return data;
  }

  clone(): ProblemDetails {
    const json = this.toJSON();
    let result = new ProblemDetails();
    result.init(json);
    return result;
  }
}

export interface IProblemDetails {
  type?: string | undefined;
  title?: string | undefined;
  status?: number | undefined;
  detail?: string | undefined;
  instance?: string | undefined;
  extensions?: { [key: string]: any; } | undefined;
}

export class UserEditViewModel extends UserBaseViewModel implements IUserEditViewModel {
  currentPassword?: string | undefined;
  newPassword?: string | undefined;
  roles?: string[] | undefined;
  isLockedOut?: boolean | undefined;

  constructor(data?: IUserEditViewModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.currentPassword = _data["currentPassword"];
      this.newPassword = _data["newPassword"];
      this.isLockedOut = _data["isLockedOut"];
      if (Array.isArray(_data["roles"])) {
        this.roles = [] as any;
        for (let item of _data["roles"])
          this.roles!.push(item);
      }
    }
  }

  static fromJS(data: any): UserEditViewModel {
    data = typeof data === 'object' ? data : {};
    let result = new UserEditViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["currentPassword"] = this.currentPassword;
    data["newPassword"] = this.newPassword;
    data["isLockedOut"] = this.isLockedOut;
    if (Array.isArray(this.roles)) {
      data["roles"] = [];
      for (let item of this.roles)
        data["roles"].push(item);
    }
    super.toJSON(data);
    return data;
  }

  clone(): UserEditViewModel {
    const json = this.toJSON();
    let result = new UserEditViewModel();
    result.init(json);
    return result;
  }
}

export interface IUserEditViewModel extends IUserBaseViewModel {
  currentPassword?: string | undefined;
  newPassword?: string | undefined;
  roles?: string[] | undefined;
  isLockedOut?: boolean | undefined;
}

export class OperationBase implements IOperationBase {
  path?: string | undefined;
  op?: string | undefined;
  from?: string | undefined;

  constructor(data?: IOperationBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.path = _data["path"];
      this.op = _data["op"];
      this.from = _data["from"];
    }
  }

  static fromJS(data: any): OperationBase {
    data = typeof data === 'object' ? data : {};
    let result = new OperationBase();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["path"] = this.path;
    data["op"] = this.op;
    data["from"] = this.from;
    return data;
  }

  clone(): OperationBase {
    const json = this.toJSON();
    let result = new OperationBase();
    result.init(json);
    return result;
  }
}

export interface IOperationBase {
  path?: string | undefined;
  op?: string | undefined;
  from?: string | undefined;
}

export class Operation extends OperationBase implements IOperation {
  value?: any | undefined;

  constructor(data?: IOperation) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.value = _data["value"];
    }
  }

  static fromJS(data: any): Operation {
    data = typeof data === 'object' ? data : {};
    let result = new Operation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["value"] = this.value;
    super.toJSON(data);
    return data;
  }

  clone(): Operation {
    const json = this.toJSON();
    let result = new Operation();
    result.init(json);
    return result;
  }
}

export interface IOperation extends IOperationBase {
  value?: any | undefined;
}

export class RoleViewModel extends ApplicationViewModelBase implements IRoleViewModel {
  id?: string | undefined;
  name!: string;
  description?: string | undefined;
  usersCount?: number;
  permissions?: PermissionViewModel[] | undefined;

  constructor(data?: IRoleViewModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.name = _data["name"];
      this.description = _data["description"];
      this.usersCount = _data["usersCount"];
      if (Array.isArray(_data["permissions"])) {
        this.permissions = [] as any;
        for (let item of _data["permissions"])
          this.permissions!.push(PermissionViewModel.fromJS(item));
      }
    }
  }

  static fromJS(data: any): RoleViewModel {
    data = typeof data === 'object' ? data : {};
    let result = new RoleViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["name"] = this.name;
    data["description"] = this.description;
    data["usersCount"] = this.usersCount;
    if (Array.isArray(this.permissions)) {
      data["permissions"] = [];
      for (let item of this.permissions)
        data["permissions"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }

  clone(): RoleViewModel {
    const json = this.toJSON();
    let result = new RoleViewModel();
    result.init(json);
    return result;
  }
}

export interface IRoleViewModel extends IApplicationViewModelBase {
  id?: string | undefined;
  name: string;
  description?: string | undefined;
  usersCount?: number;
  permissions?: PermissionViewModel[] | undefined;
}

export class PermissionViewModel extends ApplicationViewModelBase implements IPermissionViewModel {
  name?: string | undefined;
  value?: string | undefined;
  groupName?: string | undefined;
  description?: string | undefined;

  constructor(data?: IPermissionViewModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.name = _data["name"];
      this.value = _data["value"];
      this.groupName = _data["groupName"];
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): PermissionViewModel {
    data = typeof data === 'object' ? data : {};
    let result = new PermissionViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["value"] = this.value;
    data["groupName"] = this.groupName;
    data["description"] = this.description;
    super.toJSON(data);
    return data;
  }

  clone(): PermissionViewModel {
    const json = this.toJSON();
    let result = new PermissionViewModel();
    result.init(json);
    return result;
  }
}

export interface IPermissionViewModel extends IApplicationViewModelBase {
  name?: string | undefined;
  value?: string | undefined;
  groupName?: string | undefined;
  description?: string | undefined;
}

export abstract class EntityBase implements IEntityBase {
  id!: string;
  createdBy!: string;
  updatedBy!: string;
  updatedDate!: Date;
  createdDate!: Date;
  rowVersion?: string | undefined;

  constructor(data?: IEntityBase) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.id = _data["id"];
      this.createdBy = _data["createdBy"];
      this.updatedBy = _data["updatedBy"];
      this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.rowVersion = _data["rowVersion"];
    }
  }

  static fromJS(data: any): EntityBase {
    data = typeof data === 'object' ? data : {};
    throw new Error("The abstract class 'EntityBase' cannot be instantiated.");
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["createdBy"] = this.createdBy;
    data["updatedBy"] = this.updatedBy;
    data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["rowVersion"] = this.rowVersion;
    return data;
  }

  clone(): EntityBase {
    throw new Error("The abstract class 'EntityBase' cannot be instantiated.");
  }
}

export interface IEntityBase {
  id: string;
  createdBy: string;
  updatedBy: string;
  updatedDate: Date;
  createdDate: Date;
  rowVersion?: string | undefined;
}

export class Event extends EntityBase implements IEvent {
  name!: string;
  description?: string | undefined;
  locations?: EventLocation[] | undefined;
  schedules?: EventSchedule[] | undefined;
  occurances?: EventOccurance[] | undefined;
  services?: EventService[] | undefined;

  constructor(data?: IEvent) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      if (Array.isArray(_data["locations"])) {
        this.locations = [] as any;
        for (let item of _data["locations"])
          this.locations!.push(EventLocation.fromJS(item));
      }
      if (Array.isArray(_data["schedules"])) {
        this.schedules = [] as any;
        for (let item of _data["schedules"])
          this.schedules!.push(EventSchedule.fromJS(item));
      }
      if (Array.isArray(_data["occurances"])) {
        this.occurances = [] as any;
        for (let item of _data["occurances"])
          this.occurances!.push(EventOccurance.fromJS(item));
      }
      if (Array.isArray(_data["services"])) {
        this.services = [] as any;
        for (let item of _data["services"])
          this.services!.push(EventService.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Event {
    data = typeof data === 'object' ? data : {};
    let result = new Event();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    if (Array.isArray(this.locations)) {
      data["locations"] = [];
      for (let item of this.locations)
        data["locations"].push(item.toJSON());
    }
    if (Array.isArray(this.schedules)) {
      data["schedules"] = [];
      for (let item of this.schedules)
        data["schedules"].push(item.toJSON());
    }
    if (Array.isArray(this.occurances)) {
      data["occurances"] = [];
      for (let item of this.occurances)
        data["occurances"].push(item.toJSON());
    }
    if (Array.isArray(this.services)) {
      data["services"] = [];
      for (let item of this.services)
        data["services"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }

  clone(): Event {
    const json = this.toJSON();
    let result = new Event();
    result.init(json);
    return result;
  }
}

export interface IEvent extends IEntityBase {
  name: string;
  description?: string | undefined;
  locations?: EventLocation[] | undefined;
  schedules?: EventSchedule[] | undefined;
  occurances?: EventOccurance[] | undefined;
  services?: EventService[] | undefined;
}

export class EventLocation extends EntityBase implements IEventLocation {
  eventId!: string;
  event?: Event | undefined;
  schedules?: EventSchedule[] | undefined;
  occurances?: EventOccurance[] | undefined;
  name!: string;
  address1!: string;
  address2?: string | undefined;
  city!: string;
  state!: string;
  zipCode!: string;

  constructor(data?: IEventLocation) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.eventId = _data["eventId"];
      this.event = _data["event"] ? Event.fromJS(_data["event"]) : <any>undefined;
      if (Array.isArray(_data["schedules"])) {
        this.schedules = [] as any;
        for (let item of _data["schedules"])
          this.schedules!.push(EventSchedule.fromJS(item));
      }
      if (Array.isArray(_data["occurances"])) {
        this.occurances = [] as any;
        for (let item of _data["occurances"])
          this.occurances!.push(EventOccurance.fromJS(item));
      }
      this.name = _data["name"];
      this.address1 = _data["address1"];
      this.address2 = _data["address2"];
      this.city = _data["city"];
      this.state = _data["state"];
      this.zipCode = _data["zipCode"];
    }
  }

  static fromJS(data: any): EventLocation {
    data = typeof data === 'object' ? data : {};
    let result = new EventLocation();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["eventId"] = this.eventId;
    data["event"] = this.event ? this.event.toJSON() : <any>undefined;
    if (Array.isArray(this.schedules)) {
      data["schedules"] = [];
      for (let item of this.schedules)
        data["schedules"].push(item.toJSON());
    }
    if (Array.isArray(this.occurances)) {
      data["occurances"] = [];
      for (let item of this.occurances)
        data["occurances"].push(item.toJSON());
    }
    data["name"] = this.name;
    data["address1"] = this.address1;
    data["address2"] = this.address2;
    data["city"] = this.city;
    data["state"] = this.state;
    data["zipCode"] = this.zipCode;
    super.toJSON(data);
    return data;
  }

  clone(): EventLocation {
    const json = this.toJSON();
    let result = new EventLocation();
    result.init(json);
    return result;
  }
}

export interface IEventLocation extends IEntityBase {
  eventId: string;
  event?: Event | undefined;
  schedules?: EventSchedule[] | undefined;
  occurances?: EventOccurance[] | undefined;
  name: string;
  address1: string;
  address2?: string | undefined;
  city: string;
  state: string;
  zipCode: string;
}

export class EventSchedule extends EntityBase implements IEventSchedule {
  eventId!: string;
  event?: Event | undefined;
  eventLocationId!: string;
  location?: EventLocation | undefined;
  occurances?: EventOccurance[] | undefined;
  daysOfTheWeek!: Days;
  startDate!: Date;
  endDate!: Date;
  startTime!: TimeOfDay;
  endTime!: TimeOfDay;
  checkInStartTime!: TimeOfDay;
  checkInEndTime!: TimeOfDay;

  constructor(data?: IEventSchedule) {
    super(data);
    if (!data) {
      this.startTime = new TimeOfDay();
      this.endTime = new TimeOfDay();
      this.checkInStartTime = new TimeOfDay();
      this.checkInEndTime = new TimeOfDay();
    }
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.eventId = _data["eventId"];
      this.event = _data["event"] ? Event.fromJS(_data["event"]) : <any>undefined;
      this.eventLocationId = _data["eventLocationId"];
      this.location = _data["location"] ? EventLocation.fromJS(_data["location"]) : <any>undefined;
      if (Array.isArray(_data["occurances"])) {
        this.occurances = [] as any;
        for (let item of _data["occurances"])
          this.occurances!.push(EventOccurance.fromJS(item));
      }
      this.daysOfTheWeek = _data["daysOfTheWeek"];
      this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
      this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
      this.startTime = _data["startTime"] ? TimeOfDay.fromJS(_data["startTime"]) : new TimeOfDay();
      this.endTime = _data["endTime"] ? TimeOfDay.fromJS(_data["endTime"]) : new TimeOfDay();
      this.checkInStartTime = _data["checkInStartTime"] ? TimeOfDay.fromJS(_data["checkInStartTime"]) : new TimeOfDay();
      this.checkInEndTime = _data["checkInEndTime"] ? TimeOfDay.fromJS(_data["checkInEndTime"]) : new TimeOfDay();
    }
  }

  static fromJS(data: any): EventSchedule {
    data = typeof data === 'object' ? data : {};
    let result = new EventSchedule();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["eventId"] = this.eventId;
    data["event"] = this.event ? this.event.toJSON() : <any>undefined;
    data["eventLocationId"] = this.eventLocationId;
    data["location"] = this.location ? this.location.toJSON() : <any>undefined;
    if (Array.isArray(this.occurances)) {
      data["occurances"] = [];
      for (let item of this.occurances)
        data["occurances"].push(item.toJSON());
    }
    data["daysOfTheWeek"] = this.daysOfTheWeek;
    data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
    data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
    data["startTime"] = this.startTime ? this.startTime.toJSON() : <any>undefined;
    data["endTime"] = this.endTime ? this.endTime.toJSON() : <any>undefined;
    data["checkInStartTime"] = this.checkInStartTime ? this.checkInStartTime.toJSON() : <any>undefined;
    data["checkInEndTime"] = this.checkInEndTime ? this.checkInEndTime.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }

  clone(): EventSchedule {
    const json = this.toJSON();
    let result = new EventSchedule();
    result.init(json);
    return result;
  }
}

export interface IEventSchedule extends IEntityBase {
  eventId: string;
  event?: Event | undefined;
  eventLocationId: string;
  location?: EventLocation | undefined;
  occurances?: EventOccurance[] | undefined;
  daysOfTheWeek: Days;
  startDate: Date;
  endDate: Date;
  startTime: TimeOfDay;
  endTime: TimeOfDay;
  checkInStartTime: TimeOfDay;
  checkInEndTime: TimeOfDay;
}

export class EventOccurance extends EntityBase implements IEventOccurance {
  eventId!: string;
  event?: Event | undefined;
  eventLocationId!: string;
  location?: EventLocation | undefined;
  eventScheduleId!: string;
  schedule?: EventSchedule | undefined;
  date!: Date;
  lead!: string;
  demerits?: Demerit[] | undefined;

  constructor(data?: IEventOccurance) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.eventId = _data["eventId"];
      this.event = _data["event"] ? Event.fromJS(_data["event"]) : <any>undefined;
      this.eventLocationId = _data["eventLocationId"];
      this.location = _data["location"] ? EventLocation.fromJS(_data["location"]) : <any>undefined;
      this.eventScheduleId = _data["eventScheduleId"];
      this.schedule = _data["schedule"] ? EventSchedule.fromJS(_data["schedule"]) : <any>undefined;
      this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
      this.lead = _data["lead"];
      if (Array.isArray(_data["demerits"])) {
        this.demerits = [] as any;
        for (let item of _data["demerits"])
          this.demerits!.push(Demerit.fromJS(item));
      }
    }
  }

  static fromJS(data: any): EventOccurance {
    data = typeof data === 'object' ? data : {};
    let result = new EventOccurance();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["eventId"] = this.eventId;
    data["event"] = this.event ? this.event.toJSON() : <any>undefined;
    data["eventLocationId"] = this.eventLocationId;
    data["location"] = this.location ? this.location.toJSON() : <any>undefined;
    data["eventScheduleId"] = this.eventScheduleId;
    data["schedule"] = this.schedule ? this.schedule.toJSON() : <any>undefined;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    data["lead"] = this.lead;
    if (Array.isArray(this.demerits)) {
      data["demerits"] = [];
      for (let item of this.demerits)
        data["demerits"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }

  clone(): EventOccurance {
    const json = this.toJSON();
    let result = new EventOccurance();
    result.init(json);
    return result;
  }
}

export interface IEventOccurance extends IEntityBase {
  eventId: string;
  event?: Event | undefined;
  eventLocationId: string;
  location?: EventLocation | undefined;
  eventScheduleId: string;
  schedule?: EventSchedule | undefined;
  date: Date;
  lead: string;
  demerits?: Demerit[] | undefined;
}

export class Demerit extends EntityBase implements IDemerit {
  guestId!: string;
  guest?: Guest | undefined;
  eventOccuranceId!: string;
  eventOccurance?: EventOccurance | undefined;
  dateTime!: Date;
  description!: string;

  constructor(data?: IDemerit) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.guestId = _data["guestId"];
      this.guest = _data["guest"] ? Guest.fromJS(_data["guest"]) : <any>undefined;
      this.eventOccuranceId = _data["eventOccuranceId"];
      this.eventOccurance = _data["eventOccurance"] ? EventOccurance.fromJS(_data["eventOccurance"]) : <any>undefined;
      this.dateTime = _data["dateTime"] ? new Date(_data["dateTime"].toString()) : <any>undefined;
      this.description = _data["description"];
    }
  }

  static fromJS(data: any): Demerit {
    data = typeof data === 'object' ? data : {};
    let result = new Demerit();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["guestId"] = this.guestId;
    data["guest"] = this.guest ? this.guest.toJSON() : <any>undefined;
    data["eventOccuranceId"] = this.eventOccuranceId;
    data["eventOccurance"] = this.eventOccurance ? this.eventOccurance.toJSON() : <any>undefined;
    data["dateTime"] = this.dateTime ? this.dateTime.toISOString() : <any>undefined;
    data["description"] = this.description;
    super.toJSON(data);
    return data;
  }

  clone(): Demerit {
    const json = this.toJSON();
    let result = new Demerit();
    result.init(json);
    return result;
  }
}

export interface IDemerit extends IEntityBase {
  guestId: string;
  guest?: Guest | undefined;
  eventOccuranceId: string;
  eventOccurance?: EventOccurance | undefined;
  dateTime: Date;
  description: string;
}

export class Guest extends EntityBase implements IGuest {
  demerits?: Demerit[] | undefined;
  eventOccurances?: GuestEventOccurance[] | undefined;
  uniqueId!: string;
  prefix?: string | undefined;
  firstName!: string;
  middleName?: string | undefined;
  lastName!: string;
  suffix?: string | undefined;
  sex!: Sexes;
  birthDate!: Date;
  phoneNumber?: string | undefined;
  emailAddress?: string | undefined;
  password!: string;
  address1?: string | undefined;
  address2?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zipCode?: string | undefined;
  establishedGuest!: boolean;
  image?: string | undefined;

  constructor(data?: IGuest) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      if (Array.isArray(_data["demerits"])) {
        this.demerits = [] as any;
        for (let item of _data["demerits"])
          this.demerits!.push(Demerit.fromJS(item));
      }
      if (Array.isArray(_data["eventOccurances"])) {
        this.eventOccurances = [] as any;
        for (let item of _data["eventOccurances"])
          this.eventOccurances!.push(GuestEventOccurance.fromJS(item));
      }
      this.uniqueId = _data["uniqueId"];
      this.prefix = _data["prefix"];
      this.firstName = _data["firstName"];
      this.middleName = _data["middleName"];
      this.lastName = _data["lastName"];
      this.suffix = _data["suffix"];
      this.sex = _data["sex"];
      this.birthDate = _data["birthDate"] ? new Date(_data["birthDate"].toString()) : <any>undefined;
      this.phoneNumber = _data["phoneNumber"];
      this.emailAddress = _data["emailAddress"];
      this.password = _data["password"];
      this.address1 = _data["address1"];
      this.address2 = _data["address2"];
      this.city = _data["city"];
      this.state = _data["state"];
      this.zipCode = _data["zipCode"];
      this.establishedGuest = _data["establishedGuest"];
      this.image = _data["image"];
    }
  }

  static fromJS(data: any): Guest {
    data = typeof data === 'object' ? data : {};
    let result = new Guest();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    if (Array.isArray(this.demerits)) {
      data["demerits"] = [];
      for (let item of this.demerits)
        data["demerits"].push(item.toJSON());
    }
    if (Array.isArray(this.eventOccurances)) {
      data["eventOccurances"] = [];
      for (let item of this.eventOccurances)
        data["eventOccurances"].push(item.toJSON());
    }
    data["uniqueId"] = this.uniqueId;
    data["prefix"] = this.prefix;
    data["firstName"] = this.firstName;
    data["middleName"] = this.middleName;
    data["lastName"] = this.lastName;
    data["suffix"] = this.suffix;
    data["sex"] = this.sex;
    data["birthDate"] = this.birthDate ? this.birthDate.toISOString() : <any>undefined;
    data["phoneNumber"] = this.phoneNumber;
    data["emailAddress"] = this.emailAddress;
    data["password"] = this.password;
    data["address1"] = this.address1;
    data["address2"] = this.address2;
    data["city"] = this.city;
    data["state"] = this.state;
    data["zipCode"] = this.zipCode;
    data["establishedGuest"] = this.establishedGuest;
    data["image"] = this.image;
    super.toJSON(data);
    return data;
  }

  clone(): Guest {
    const json = this.toJSON();
    let result = new Guest();
    result.init(json);
    return result;
  }
}

export interface IGuest extends IEntityBase {
  demerits?: Demerit[] | undefined;
  eventOccurances?: GuestEventOccurance[] | undefined;
  uniqueId: string;
  prefix?: string | undefined;
  firstName: string;
  middleName?: string | undefined;
  lastName: string;
  suffix?: string | undefined;
  sex: Sexes;
  birthDate: Date;
  phoneNumber?: string | undefined;
  emailAddress?: string | undefined;
  password: string;
  address1?: string | undefined;
  address2?: string | undefined;
  city?: string | undefined;
  state?: string | undefined;
  zipCode?: string | undefined;
  establishedGuest: boolean;
  image?: string | undefined;
}

export class GuestEventOccurance extends EntityBase implements IGuestEventOccurance {
  guestId!: string;
  guest?: Guest | undefined;
  eventOccuranceId!: string;
  eventOccurance?: EventOccurance | undefined;

  constructor(data?: IGuestEventOccurance) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.guestId = _data["guestId"];
      this.guest = _data["guest"] ? Guest.fromJS(_data["guest"]) : <any>undefined;
      this.eventOccuranceId = _data["eventOccuranceId"];
      this.eventOccurance = _data["eventOccurance"] ? EventOccurance.fromJS(_data["eventOccurance"]) : <any>undefined;
    }
  }

  static fromJS(data: any): GuestEventOccurance {
    data = typeof data === 'object' ? data : {};
    let result = new GuestEventOccurance();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["guestId"] = this.guestId;
    data["guest"] = this.guest ? this.guest.toJSON() : <any>undefined;
    data["eventOccuranceId"] = this.eventOccuranceId;
    data["eventOccurance"] = this.eventOccurance ? this.eventOccurance.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }

  clone(): GuestEventOccurance {
    const json = this.toJSON();
    let result = new GuestEventOccurance();
    result.init(json);
    return result;
  }
}

export interface IGuestEventOccurance extends IEntityBase {
  guestId: string;
  guest?: Guest | undefined;
  eventOccuranceId: string;
  eventOccurance?: EventOccurance | undefined;
}

/** 0 = Male 1 = Female */
export enum Sexes {
  Male = 0,
  Female = 1,
}

/** 0 = Sunday 1 = Monday 2 = Tuesday 3 = Wednesday 4 = Thursday 5 = Friday 6 = Saturaday */
export enum Days {
  Sunday = 0,
  Monday = 1,
  Tuesday = 2,
  Wednesday = 3,
  Thursday = 4,
  Friday = 5,
  Saturaday = 6,
}

export class TimeOfDay implements ITimeOfDay {
  hhmmss?: number;
  hour?: number;
  minute?: number;
  second?: number;
  totalDays?: number;
  totalHours?: number;
  totalMinutes?: number;
  totalSeconds?: number;

  constructor(data?: ITimeOfDay) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.hhmmss = _data["hhmmss"];
      this.hour = _data["hour"];
      this.minute = _data["minute"];
      this.second = _data["second"];
      this.totalDays = _data["totalDays"];
      this.totalHours = _data["totalHours"];
      this.totalMinutes = _data["totalMinutes"];
      this.totalSeconds = _data["totalSeconds"];
    }
  }

  static fromJS(data: any): TimeOfDay {
    data = typeof data === 'object' ? data : {};
    let result = new TimeOfDay();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["hhmmss"] = this.hhmmss;
    data["hour"] = this.hour;
    data["minute"] = this.minute;
    data["second"] = this.second;
    data["totalDays"] = this.totalDays;
    data["totalHours"] = this.totalHours;
    data["totalMinutes"] = this.totalMinutes;
    data["totalSeconds"] = this.totalSeconds;
    return data;
  }

  clone(): TimeOfDay {
    const json = this.toJSON();
    let result = new TimeOfDay();
    result.init(json);
    return result;
  }
}

export interface ITimeOfDay {
  hhmmss?: number;
  hour?: number;
  minute?: number;
  second?: number;
  totalDays?: number;
  totalHours?: number;
  totalMinutes?: number;
  totalSeconds?: number;
}

export class EventService extends EntityBase implements IEventService {
  eventId!: string;
  event?: Event | undefined;
  serviceId!: string;
  service?: Service | undefined;

  constructor(data?: IEventService) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.eventId = _data["eventId"];
      this.event = _data["event"] ? Event.fromJS(_data["event"]) : <any>undefined;
      this.serviceId = _data["serviceId"];
      this.service = _data["service"] ? Service.fromJS(_data["service"]) : <any>undefined;
    }
  }

  static fromJS(data: any): EventService {
    data = typeof data === 'object' ? data : {};
    let result = new EventService();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["eventId"] = this.eventId;
    data["event"] = this.event ? this.event.toJSON() : <any>undefined;
    data["serviceId"] = this.serviceId;
    data["service"] = this.service ? this.service.toJSON() : <any>undefined;
    super.toJSON(data);
    return data;
  }

  clone(): EventService {
    const json = this.toJSON();
    let result = new EventService();
    result.init(json);
    return result;
  }
}

export interface IEventService extends IEntityBase {
  eventId: string;
  event?: Event | undefined;
  serviceId: string;
  service?: Service | undefined;
}

export class Service extends EntityBase implements IService {
  name!: string;
  description!: string;
  serviceType!: ServiceTypes;
  eventServices?: EventService[] | undefined;

  constructor(data?: IService) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.name = _data["name"];
      this.description = _data["description"];
      this.serviceType = _data["serviceType"];
      if (Array.isArray(_data["eventServices"])) {
        this.eventServices = [] as any;
        for (let item of _data["eventServices"])
          this.eventServices!.push(EventService.fromJS(item));
      }
    }
  }

  static fromJS(data: any): Service {
    data = typeof data === 'object' ? data : {};
    let result = new Service();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["name"] = this.name;
    data["description"] = this.description;
    data["serviceType"] = this.serviceType;
    if (Array.isArray(this.eventServices)) {
      data["eventServices"] = [];
      for (let item of this.eventServices)
        data["eventServices"].push(item.toJSON());
    }
    super.toJSON(data);
    return data;
  }

  clone(): Service {
    const json = this.toJSON();
    let result = new Service();
    result.init(json);
    return result;
  }
}

export interface IService extends IEntityBase {
  name: string;
  description: string;
  serviceType: ServiceTypes;
  eventServices?: EventService[] | undefined;
}

/** 0 = Normal 1 = Queue 2 = Time */
export enum ServiceTypes {
  Normal = 0,
  Queue = 1,
  Time = 2,
}

export class ExtendedLogViewModel extends ApplicationViewModelBase implements IExtendedLogViewModel {
  browser?: string | undefined;
  host?: string | undefined;
  path?: string | undefined;
  user?: string | undefined;
  eventId?: number;
  id?: string | undefined;
  level?: number;
  levelDescription?: string | undefined;
  message?: string | undefined;
  name?: string | undefined;
  method?: string | undefined;
  statusCode?: number;
  serverVariables?: string | undefined;
  cookies?: string | undefined;
  formVariables?: string | undefined;
  queryString?: string | undefined;
  timeStamp?: Date;

  constructor(data?: IExtendedLogViewModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.browser = _data["browser"];
      this.host = _data["host"];
      this.path = _data["path"];
      this.user = _data["user"];
      this.eventId = _data["eventId"];
      this.id = _data["id"];
      this.level = _data["level"];
      this.levelDescription = _data["levelDescription"];
      this.message = _data["message"];
      this.name = _data["name"];
      this.method = _data["method"];
      this.statusCode = _data["statusCode"];
      this.serverVariables = _data["serverVariables"];
      this.cookies = _data["cookies"];
      this.formVariables = _data["formVariables"];
      this.queryString = _data["queryString"];
      this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): ExtendedLogViewModel {
    data = typeof data === 'object' ? data : {};
    let result = new ExtendedLogViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["browser"] = this.browser;
    data["host"] = this.host;
    data["path"] = this.path;
    data["user"] = this.user;
    data["eventId"] = this.eventId;
    data["id"] = this.id;
    data["level"] = this.level;
    data["levelDescription"] = this.levelDescription;
    data["message"] = this.message;
    data["name"] = this.name;
    data["method"] = this.method;
    data["statusCode"] = this.statusCode;
    data["serverVariables"] = this.serverVariables;
    data["cookies"] = this.cookies;
    data["formVariables"] = this.formVariables;
    data["queryString"] = this.queryString;
    data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
    super.toJSON(data);
    return data;
  }

  clone(): ExtendedLogViewModel {
    const json = this.toJSON();
    let result = new ExtendedLogViewModel();
    result.init(json);
    return result;
  }
}

export interface IExtendedLogViewModel extends IApplicationViewModelBase {
  browser?: string | undefined;
  host?: string | undefined;
  path?: string | undefined;
  user?: string | undefined;
  eventId?: number;
  id?: string | undefined;
  level?: number;
  levelDescription?: string | undefined;
  message?: string | undefined;
  name?: string | undefined;
  method?: string | undefined;
  statusCode?: number;
  serverVariables?: string | undefined;
  cookies?: string | undefined;
  formVariables?: string | undefined;
  queryString?: string | undefined;
  timeStamp?: Date;
}

export class LogOfString implements ILogOfString {
  eventId?: number;
  id?: string | undefined;
  level?: number;
  message?: string | undefined;
  name?: string | undefined;
  timeStamp?: Date;

  constructor(data?: ILogOfString) {
    if (data) {
      for (var property in data) {
        if (data.hasOwnProperty(property))
          (<any>this)[property] = (<any>data)[property];
      }
    }
  }

  init(_data?: any) {
    if (_data) {
      this.eventId = _data["eventId"];
      this.id = _data["id"];
      this.level = _data["level"];
      this.message = _data["message"];
      this.name = _data["name"];
      this.timeStamp = _data["timeStamp"] ? new Date(_data["timeStamp"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): LogOfString {
    data = typeof data === 'object' ? data : {};
    let result = new LogOfString();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["eventId"] = this.eventId;
    data["id"] = this.id;
    data["level"] = this.level;
    data["message"] = this.message;
    data["name"] = this.name;
    data["timeStamp"] = this.timeStamp ? this.timeStamp.toISOString() : <any>undefined;
    return data;
  }

  clone(): LogOfString {
    const json = this.toJSON();
    let result = new LogOfString();
    result.init(json);
    return result;
  }
}

export interface ILogOfString {
  eventId?: number;
  id?: string | undefined;
  level?: number;
  message?: string | undefined;
  name?: string | undefined;
  timeStamp?: Date;
}

export class ExtendedLog extends LogOfString implements IExtendedLog {
  levelDescription?: string | undefined;
  browser?: string | undefined;
  host?: string | undefined;
  path?: string | undefined;
  user?: string | undefined;
  method?: string | undefined;
  statusCode?: number;
  serverVariables?: string | undefined;
  cookies?: string | undefined;
  formVariables?: string | undefined;
  queryString?: string | undefined;
  createdBy!: string;
  updatedBy!: string;
  updatedDate!: Date;
  createdDate!: Date;
  rowVersion?: string | undefined;

  constructor(data?: IExtendedLog) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.levelDescription = _data["levelDescription"];
      this.browser = _data["browser"];
      this.host = _data["host"];
      this.path = _data["path"];
      this.user = _data["user"];
      this.method = _data["method"];
      this.statusCode = _data["statusCode"];
      this.serverVariables = _data["serverVariables"];
      this.cookies = _data["cookies"];
      this.formVariables = _data["formVariables"];
      this.queryString = _data["queryString"];
      this.createdBy = _data["createdBy"];
      this.updatedBy = _data["updatedBy"];
      this.updatedDate = _data["updatedDate"] ? new Date(_data["updatedDate"].toString()) : <any>undefined;
      this.createdDate = _data["createdDate"] ? new Date(_data["createdDate"].toString()) : <any>undefined;
      this.rowVersion = _data["rowVersion"];
    }
  }

  static fromJS(data: any): ExtendedLog {
    data = typeof data === 'object' ? data : {};
    let result = new ExtendedLog();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["levelDescription"] = this.levelDescription;
    data["browser"] = this.browser;
    data["host"] = this.host;
    data["path"] = this.path;
    data["user"] = this.user;
    data["method"] = this.method;
    data["statusCode"] = this.statusCode;
    data["serverVariables"] = this.serverVariables;
    data["cookies"] = this.cookies;
    data["formVariables"] = this.formVariables;
    data["queryString"] = this.queryString;
    data["createdBy"] = this.createdBy;
    data["updatedBy"] = this.updatedBy;
    data["updatedDate"] = this.updatedDate ? this.updatedDate.toISOString() : <any>undefined;
    data["createdDate"] = this.createdDate ? this.createdDate.toISOString() : <any>undefined;
    data["rowVersion"] = this.rowVersion;
    super.toJSON(data);
    return data;
  }

  clone(): ExtendedLog {
    const json = this.toJSON();
    let result = new ExtendedLog();
    result.init(json);
    return result;
  }
}

export interface IExtendedLog extends ILogOfString {
  levelDescription?: string | undefined;
  browser?: string | undefined;
  host?: string | undefined;
  path?: string | undefined;
  user?: string | undefined;
  method?: string | undefined;
  statusCode?: number;
  serverVariables?: string | undefined;
  cookies?: string | undefined;
  formVariables?: string | undefined;
  queryString?: string | undefined;
  createdBy: string;
  updatedBy: string;
  updatedDate: Date;
  createdDate: Date;
  rowVersion?: string | undefined;
}

export class NotificationViewModel extends ApplicationViewModelBase implements INotificationViewModel {
  id?: string | undefined;
  header?: string | undefined;
  body?: string | undefined;
  isRead?: boolean;
  isPinned?: boolean;
  date?: Date;

  constructor(data?: INotificationViewModel) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.id = _data["id"];
      this.header = _data["header"];
      this.body = _data["body"];
      this.isRead = _data["isRead"];
      this.isPinned = _data["isPinned"];
      this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): NotificationViewModel {
    data = typeof data === 'object' ? data : {};
    let result = new NotificationViewModel();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["id"] = this.id;
    data["header"] = this.header;
    data["body"] = this.body;
    data["isRead"] = this.isRead;
    data["isPinned"] = this.isPinned;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    super.toJSON(data);
    return data;
  }

  clone(): NotificationViewModel {
    const json = this.toJSON();
    let result = new NotificationViewModel();
    result.init(json);
    return result;
  }
}

export interface INotificationViewModel extends IApplicationViewModelBase {
  id?: string | undefined;
  header?: string | undefined;
  body?: string | undefined;
  isRead?: boolean;
  isPinned?: boolean;
  date?: Date;
}

export class Notification extends EntityBase implements INotification {
  header!: string;
  body!: string;
  isRead?: boolean;
  isPinned?: boolean;
  date!: Date;

  constructor(data?: INotification) {
    super(data);
  }

  init(_data?: any) {
    super.init(_data);
    if (_data) {
      this.header = _data["header"];
      this.body = _data["body"];
      this.isRead = _data["isRead"];
      this.isPinned = _data["isPinned"];
      this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
    }
  }

  static fromJS(data: any): Notification {
    data = typeof data === 'object' ? data : {};
    let result = new Notification();
    result.init(data);
    return result;
  }

  toJSON(data?: any) {
    data = typeof data === 'object' ? data : {};
    data["header"] = this.header;
    data["body"] = this.body;
    data["isRead"] = this.isRead;
    data["isPinned"] = this.isPinned;
    data["date"] = this.date ? this.date.toISOString() : <any>undefined;
    super.toJSON(data);
    return data;
  }

  clone(): Notification {
    const json = this.toJSON();
    let result = new Notification();
    result.init(json);
    return result;
  }
}

export interface INotification extends IEntityBase {
  header: string;
  body: string;
  isRead?: boolean;
  isPinned?: boolean;
  date: Date;
}

export class ServiceException extends Error {
  message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isServiceException = true;

  static isServiceException(obj: any): obj is ServiceException {
    return obj.isServiceException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new ServiceException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((<any>event.target).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}

export type PermissionName =
  'View Logs' | 'Manage Logs' |
  'View Events' | 'Manage Events' | 'Execute Events' |
  'View Users' | 'Manage Users' |
  'View Roles' | 'Manage Roles' | 'Assign Roles';

export type PermissionValue =
  'logs.view' | 'logs.manage' |
  'events.view' | 'events.manage' | 'events.execute' |
  'users.view' | 'users.manage' |
  'roles.view' | 'roles.manage' | 'roles.assign';

export class PermissionValues {
  public static readonly ViewLogs: PermissionValue = 'logs.view';
  public static readonly ManageLogs: PermissionValue = 'logs.manage';

  public static readonly ViewEvents: PermissionValue = 'events.view';
  public static readonly ManageEvents: PermissionValue = 'events.manage';
  public static readonly ExecuteEvents: PermissionValue = 'events.execute';

  public static readonly ViewUsers: PermissionValue = 'users.view';
  public static readonly ManageUsers: PermissionValue = 'users.manage';

  public static readonly ViewRoles: PermissionValue = 'roles.view';
  public static readonly ManageRoles: PermissionValue = 'roles.manage';
  public static readonly AssignRoles: PermissionValue = 'roles.assign';
}
